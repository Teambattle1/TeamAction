import React, { useState, useEffect, useRef } from 'react';
import { Game, Playground, GamePoint, IconId, TaskTemplate, TaskList, DeviceType, PlaygroundTemplate } from '../types';
import { DEVICE_SPECS, getDeviceLayout, ensureDeviceLayouts, DEVICE_SPECS as SPECS } from '../utils/deviceUtils';
import {
    X, Plus, LayoutGrid, Globe, Map as MapIcon, ArrowLeft, Trash2, Edit2,
    Image as ImageIcon, Upload, Grid, MousePointer2, Move, ZoomIn, ZoomOut,
    Maximize, Lock, Unlock, Settings, Home, Save, Check, Type, Gamepad2, Library, Users, Shield,
    Smartphone, Tablet, Monitor, MousePointerClick, Music, Repeat, PlayCircle, ChevronLeft, ChevronRight, ChevronDown, ChevronsUpDown,
    Wand2, Zap, CheckCircle, XCircle, GripHorizontal, AlertTriangle, QrCode, Target, Loader2, MapPin, Copy, Eye, PenTool, Trophy, Download
} from 'lucide-react';
import { ICON_COMPONENTS } from '../utils/icons';
import { uploadImage } from '../services/storage'; // IMPORTED
import { generateAiImage, generateAiBackground, searchLogoUrl } from '../services/ai';
import * as db from '../services/db';
import { snapPointsToRoad, isPointInBox } from '../utils/mapbox';
import jsQR from 'jsqr';
import QRScannerModal from './QRScannerModal';
import { getGlobalCorrectSound, getGlobalIncorrectSound, getGlobalVolume } from '../utils/sounds';
import TaskActionModal from './TaskActionModal';
import AiTaskGenerator from './AiTaskGenerator';
import TaskMaster from './TaskMaster';
import TaskEditor from './TaskEditor';
import GeminiApiKeyModal from './GeminiApiKeyModal';
import TaskModal from './TaskModal';

interface PlaygroundEditorProps {
  game: Game;
  onUpdateGame: (game: Game) => void;
  onClose: () => void;
  onEditPoint: (point: GamePoint) => void;
  onPointClick: (point: GamePoint) => void;
  onAddTask: (type: 'MANUAL' | 'AI' | 'LIBRARY', playgroundId?: string) => void;
  onOpenLibrary: (playgroundId: string) => void;
  showScores: boolean;
  onToggleScores: () => void;
  onHome: () => void;
  onSaveTemplate?: (name: string) => void;
  isTemplateMode: boolean;
  onAddZoneFromLibrary: () => void;
  onOpenPlayground?: (id: string) => void; // Optional prop for compatibility
  isAdmin?: boolean; // Admin privilege for task status marking
  onStartSimulation?: () => void; // Start simulation mode from editor
  taskLists: TaskList[]; // Task lists for TaskMaster
  onUpdateTaskLists: (lists: TaskList[]) => void; // Update task lists
  taskLibrary: TaskTemplate[]; // Task library for TaskMaster
  onUpdateTaskLibrary: (library: TaskTemplate[]) => void; // Update task library
  onOpenGameSettings?: () => void; // Open game settings
  onExportGameToLibrary?: () => void; // Export all tasks to library
}

const PlaygroundEditor: React.FC<PlaygroundEditorProps> = ({
    game,
    onUpdateGame,
    onClose,
    onEditPoint,
    onPointClick,
    onAddTask,
    onOpenLibrary,
    showScores,
    onToggleScores,
    onHome,
    onSaveTemplate,
    isTemplateMode,
    onAddZoneFromLibrary,
    taskLists,
    onUpdateTaskLists,
    taskLibrary,
    onUpdateTaskLibrary,
    isAdmin = false,
    onStartSimulation,
    onOpenGameSettings,
    onExportGameToLibrary
}) => {
    // State
    const [activePlaygroundId, setActivePlaygroundId] = useState<string | null>(null);
    const [zoom, setZoom] = useState(1);
    const [pan, setPan] = useState({ x: 0, y: 0 });
    const [isDragging, setIsDragging] = useState(false);
    const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
    const [isSaving, setIsSaving] = useState(false);
    const [saveStatus, setSaveStatus] = useState<'idle' | 'saving' | 'success'>('idle');
    const [isDrawerOpen, setIsDrawerOpen] = useState(true); // Open by default
    const [isTasksDrawerOpen, setIsTasksDrawerOpen] = useState(true); // Open by default
    const [showGrid, setShowGrid] = useState(false);
    const [selectedTaskId, setSelectedTaskId] = useState<string | null>(null);
    const [isGeneratingIcon, setIsGeneratingIcon] = useState(false);
    const [showActionModal, setShowActionModal] = useState(false);
    const [showAiTaskGenerator, setShowAiTaskGenerator] = useState(false);
    const [showTaskScores, setShowTaskScores] = useState(true);
    const [showTaskOrder, setShowTaskOrder] = useState(true);
    const [showTaskActions, setShowTaskActions] = useState(true);
    const [showTaskStatus, setShowTaskStatus] = useState(true);
    const [showTaskNames, setShowTaskNames] = useState(true);
    const [showBackground, setShowBackground] = useState(true);
    const [isBackgroundLocked, setIsBackgroundLocked] = useState(false);

    // Simulation Mode State
    const [isSimulationActive, setIsSimulationActive] = useState(false);
    const [simulationScore, setSimulationScore] = useState(0);
    const [simulationTeam, setSimulationTeam] = useState<any | null>(null);
    const [showRanking, setShowRanking] = useState(false);
    const [rankingPos, setRankingPos] = useState({ x: window.innerWidth - 350, y: 100 });
    const [isDraggingRanking, setIsDraggingRanking] = useState(false);
    const rankingDragOffset = useRef({ x: 0, y: 0 });
    const [activeSimulationTaskId, setActiveSimulationTaskId] = useState<string | null>(null);

    // Audio refs for simulation mode
    const simulationBgAudioRef = useRef<HTMLAudioElement | null>(null);

    // Draw Mode State for Visual Connections
    const [drawMode, setDrawMode] = useState<{
        active: boolean;
        trigger: 'onOpen' | 'onCorrect' | 'onIncorrect' | null;
        sourceTaskId: string | null;
        mousePosition: { x: number; y: number } | null;
    }>({ active: false, trigger: null, sourceTaskId: null, mousePosition: null });

    const editorRootRef = useRef<HTMLDivElement>(null);
    const drawCanvasRef = useRef<HTMLDivElement>(null);

    const getDefaultEditorToolbarPositions = () => {
        const rootWidth = editorRootRef.current?.getBoundingClientRect().width || (typeof window !== 'undefined' ? window.innerWidth : 1200);

        // Default: top row under the header (matches the desired "Picture 2" desktop layout)
        const y = 88;

        // Approximate widths (used only to compute non-overlapping start X positions)
        const gap = 14;
        const orientationW = 470;
        const showW = 320;
        const toolsW = 320;

        const totalW = orientationW + showW + toolsW + gap * 2;
        const startX = Math.max(20, Math.round((rootWidth - totalW) / 2));

        return {
            orientation: { x: startX, y },
            show: { x: startX + orientationW + gap, y },
            tools: { x: startX + orientationW + gap + showW + gap, y },
        };
    };

    // Toolbar positions (draggable) - Default spread-out positions to avoid overlap
    const initialToolbarDefaults = getDefaultEditorToolbarPositions();
    const [orientationToolbarPos, setOrientationToolbarPos] = useState(initialToolbarDefaults.orientation);
    const [showToolbarPos, setShowToolbarPos] = useState(initialToolbarDefaults.show);
    const [toolsToolbarPos, setToolsToolbarPos] = useState(initialToolbarDefaults.tools);
    const [qrScannerPos, setQRScannerPos] = useState({ x: 85, y: 85 }); // Percentage-based positioning (85%, 85%)
    const [qrScannerSize, setQRScannerSize] = useState({ width: 140, height: 48 });
    const [qrScannerColor, setQRScannerColor] = useState('#f97316'); // Orange-500
    const [isDraggingOrientation, setIsDraggingOrientation] = useState(false);
    const [isDraggingShow, setIsDraggingShow] = useState(false);
    const [isDraggingTools, setIsDraggingTools] = useState(false);
    const [isDraggingQRScanner, setIsDraggingQRScanner] = useState(false);
    const [isResizingQRScanner, setIsResizingQRScanner] = useState(false);
    const [showQRColorPicker, setShowQRColorPicker] = useState(false);
    const [isQRScannerActive, setIsQRScannerActive] = useState(false);
    const [qrScannedValue, setQRScannedValue] = useState<string | null>(null);
    const qrScannerResizeStart = useRef({ width: 0, height: 0, x: 0, y: 0 });
    const qrScannerDidDrag = useRef(false);
    const qrScannerClickTimer = useRef<NodeJS.Timeout | null>(null);
    const qrScannerClickCount = useRef(0);
    const qrScannerButtonDownPos = useRef({ x: 0, y: 0 });
    const qrScannerHasMoved = useRef(false);

    // Device-specific layout management
    // Smart device initialization: desktop for new playgrounds, last used for existing
    const [selectedDevice, setSelectedDevice] = useState<DeviceType>(() => {
        // Check if this is a new playground (no tasks yet)
        const playgroundId = game.playgrounds?.[0]?.id || activePlaygroundId;
        const playgroundTasks = game.points?.filter(p => p.playgroundId === playgroundId) || [];
        const isNewPlayground = playgroundTasks.length === 0;

        if (isNewPlayground) {
            // New playground: start with desktop mode
            return 'desktop';
        } else {
            // Existing playground: load last used device from localStorage
            const storageKey = `playzone_device_${playgroundId}`;
            const savedDevice = localStorage.getItem(storageKey);
            return (savedDevice as DeviceType) || 'desktop';
        }
    });
    const [deviceLayoutsCache, setDeviceLayoutsCache] = useState<Record<DeviceType, any> | null>(null);
    const orientationDragOffset = useRef({ x: 0, y: 0 });
    const showDragOffset = useRef({ x: 0, y: 0 });
    const toolsDragOffset = useRef({ x: 0, y: 0 });
    const qrScannerDragOffset = useRef({ x: 0, y: 0 });
    const qrVideoRef = useRef<HTMLVideoElement>(null);
    const qrCanvasRef = useRef<HTMLCanvasElement>(null);
    const qrStreamRef = useRef<MediaStream | null>(null);
    const qrScanIntervalRef = useRef<NodeJS.Timeout | null>(null);

    const [editorOrientation, setEditorOrientation] = useState<'portrait' | 'landscape'>('landscape');
    const [showAiIconPrompt, setShowAiIconPrompt] = useState(false);
    const [aiIconPromptValue, setAiIconPromptValue] = useState('');
    const [showLogoPrompt, setShowLogoPrompt] = useState(false);
    const [logoCompanyName, setLogoCompanyName] = useState('');
    const [isSearchingLogo, setIsSearchingLogo] = useState(false);
    const [editingCompletedIcon, setEditingCompletedIcon] = useState(false); // Track if editing completed icon
    const [isMarkMode, setIsMarkMode] = useState(false);
    const [markedTaskIds, setMarkedTaskIds] = useState<Set<string>>(new Set());
    const [hoveredTaskId, setHoveredTaskId] = useState<string | null>(null);
    const [showQRScanner, setShowQRScanner] = useState(true);
    const [showTaskMaster, setShowTaskMaster] = useState(false);
    const [taskMasterTab, setTaskMasterTab] = useState<'LIBRARY' | 'LISTS'>('LIBRARY');
    const [editingTitleId, setEditingTitleId] = useState<string | null>(null);
    const [editingTitleValue, setEditingTitleValue] = useState('');
    const [taskSortMode, setTaskSortMode] = useState<'order' | 'actions'>('order');
    const [collapsedSources, setCollapsedSources] = useState<Set<string>>(new Set());
    const [bulkIconSourceId, setBulkIconSourceId] = useState<string | null>(null);
    const [bulkIconMode, setBulkIconMode] = useState(false);
    const [bulkIconTargets, setBulkIconTargets] = useState<Set<string>>(new Set());

    // Playzone selection for task/AI import
    const [showPlayzoneSelector, setShowPlayzoneSelector] = useState(false);
    const [pendingTasksToAdd, setPendingTasksToAdd] = useState<TaskTemplate[]>([]);
    const [isAddingAITasks, setIsAddingAITasks] = useState(false);
    const [isAddingTaskList, setIsAddingTaskList] = useState(false);

    // AI Background Generation
    const [showAiBackgroundPrompt, setShowAiBackgroundPrompt] = useState(false);
    const [aiBackgroundPromptValue, setAiBackgroundPromptValue] = useState('');
    const [isGeneratingBackground, setIsGeneratingBackground] = useState(false);
    const [showGeminiKeyModal, setShowGeminiKeyModal] = useState(false);
    const [pendingBackgroundKeywords, setPendingBackgroundKeywords] = useState<string | null>(null);

    // Delete Zone State
    const [isOverDeleteZone, setIsOverDeleteZone] = useState(false);

    // Collapse State for Left Drawer Sections (default: all collapsed)
    const [isHudAppearanceCollapsed, setIsHudAppearanceCollapsed] = useState(true);
    const [isBackgroundImageCollapsed, setIsBackgroundImageCollapsed] = useState(true);
    const [isBackgroundMusicCollapsed, setIsBackgroundMusicCollapsed] = useState(true);
    const [isDeviceCollapsed, setIsDeviceCollapsed] = useState(true); // Collapsed by default
    const [isOrientationCollapsed, setIsOrientationCollapsed] = useState(true); // Collapsed by default
    const [isShowCollapsed, setIsShowCollapsed] = useState(true); // Collapsed by default
    const [isLayoutCollapsed, setIsLayoutCollapsed] = useState(true); // Collapsed by default

    // Toggle all sections collapsed/expanded (excluding HUD appearance)
    const toggleAllSections = () => {
        // Check if any section is expanded (excluding HUD)
        const anyExpanded = !isBackgroundImageCollapsed ||
                           !isBackgroundMusicCollapsed || !isDeviceCollapsed ||
                           !isOrientationCollapsed || !isShowCollapsed || !isLayoutCollapsed;

        // If any are expanded, collapse all. Otherwise, expand all.
        const newState = anyExpanded;
        setIsBackgroundImageCollapsed(newState);
        setIsBackgroundMusicCollapsed(newState);
        setIsDeviceCollapsed(newState);
        setIsOrientationCollapsed(newState);
        setIsShowCollapsed(newState);
        setIsLayoutCollapsed(newState);
    };

    // Snap to Road State
    const [snapToRoadMode, setSnapToRoadMode] = useState(false);
    const [selectionBox, setSelectionBox] = useState<{ start: { x: number; y: number } | null; current: { x: number; y: number } | null }>({ start: null, current: null });

    // Task Settings Modal State
    const [showTaskSettingsModal, setShowTaskSettingsModal] = useState(false);
    const [settingsModalTaskId, setSettingsModalTaskId] = useState<string | null>(null);
    const [showTaskViewModal, setShowTaskViewModal] = useState(false);

    // Refs
    const fileInputRef = useRef<HTMLInputElement>(null);
    const iconInputRef = useRef<HTMLInputElement>(null);
    const audioInputRef = useRef<HTMLInputElement>(null);
    const taskIconInputRef = useRef<HTMLInputElement>(null);
    const completedTaskIconInputRef = useRef<HTMLInputElement>(null);
    const canvasRef = useRef<HTMLDivElement>(null);
    const backgroundRef = useRef<HTMLDivElement>(null);

    const [draggingTaskId, setDraggingTaskId] = useState<string | null>(null);
    const [dragVisualPosition, setDragVisualPosition] = useState<{ x: number; y: number } | null>(null);
    const dragTaskRef = useRef<{
        id: string | null;
        offsetX: number;
        offsetY: number;
        startClientX: number;
        startClientY: number;
        moved: boolean;
    }>({ id: null, offsetX: 0, offsetY: 0, startClientX: 0, startClientY: 0, moved: false });

    // Initialize active playground
    useEffect(() => {
        if (!activePlaygroundId && game.playgrounds && game.playgrounds.length > 0) {
            setActivePlaygroundId(game.playgrounds[0].id);
        } else if (!game.playgrounds || game.playgrounds.length === 0) {
            // Auto-create if none exists with full device layouts configuration

            const newPg: Playground = {
                id: `pg-${Date.now()}`,
                title: 'Global 1',
                buttonVisible: true,
                iconId: 'default',
                location: { lat: 0, lng: 0 },
                orientationLock: 'landscape',
                deviceLayouts: {
                    mobile: {
                        orientationLock: 'landscape',
                        qrScannerPos: { x: 85, y: 85 }, // Percentage-based (85%, 85%)
                        qrScannerSize: { width: 140, height: 48 },
                        qrScannerColor: '#f97316', // Orange-500 default
                        iconPositions: {},
                        buttonVisible: true,
                        iconScale: 1.0,
                    },
                    tablet: {
                        orientationLock: 'landscape',
                        qrScannerPos: { x: 85, y: 85 }, // Percentage-based (85%, 85%)
                        qrScannerSize: { width: 140, height: 48 },
                        qrScannerColor: '#f97316', // Orange-500 default
                        iconPositions: {},
                        buttonVisible: true,
                        iconScale: 1.0,
                    },
                    desktop: {
                        orientationLock: 'landscape',
                        qrScannerPos: { x: 85, y: 85 }, // Percentage-based (85%, 85%)
                        qrScannerSize: { width: 140, height: 48 },
                        qrScannerColor: '#f97316', // Orange-500 default
                        iconPositions: {},
                        buttonVisible: true,
                        iconScale: 1.0,
                    },
                },
            };

            // Initialize default toolbar positions for new games
        const defaultPos = getDefaultEditorToolbarPositions();
        const defaultToolbarPositions = {
            editorOrientationPos: defaultPos.orientation,
            editorShowPos: defaultPos.show,
            editorToolsPos: defaultPos.tools,
        };

            onUpdateGame({
                ...game,
                playgrounds: [newPg],
                toolbarPositions: defaultToolbarPositions
            });
            setActivePlaygroundId(newPg.id);

            // Drawers open by default (already set in useState, but kept for clarity)
            setIsDrawerOpen(true);
            setIsTasksDrawerOpen(true);
        }
    }, [game.playgrounds]);

    // ESC key listener for draw mode
    useEffect(() => {
        const handleEscKey = (e: KeyboardEvent) => {
            if (e.key === 'Escape' && drawMode.active) {
                setDrawMode({ active: false, trigger: null, sourceTaskId: null, mousePosition: null });
            }
        };

        window.addEventListener('keydown', handleEscKey);
        return () => window.removeEventListener('keydown', handleEscKey);
    }, [drawMode.active]);

    const didSeedEditorToolbarPositionsRef = useRef(false);

    // Load toolbar positions from game (device-aware)
    useEffect(() => {
        const pos = game.toolbarPositions;

        // Default positions - spread out horizontally on the top row
        const defaults = getDefaultEditorToolbarPositions();
        const defaultOrientationPos = defaults.orientation;
        const defaultShowPos = defaults.show;
        const defaultToolsPos = defaults.tools;

        // Try device-specific positions first, fall back to default, then to hardcoded defaults
        if (pos?.editorOrientationPosPerDevice?.[selectedDevice]) {
            setOrientationToolbarPos(pos.editorOrientationPosPerDevice[selectedDevice]);
        } else if (pos?.editorOrientationPos) {
            setOrientationToolbarPos(pos.editorOrientationPos);
        } else {
            setOrientationToolbarPos(defaultOrientationPos);
        }

        if (pos?.editorShowPosPerDevice?.[selectedDevice]) {
            setShowToolbarPos(pos.editorShowPosPerDevice[selectedDevice]);
        } else if (pos?.editorShowPos) {
            setShowToolbarPos(pos.editorShowPos);
        } else {
            setShowToolbarPos(defaultShowPos);
        }

        if (pos?.editorToolsPosPerDevice?.[selectedDevice]) {
            setToolsToolbarPos(pos.editorToolsPosPerDevice[selectedDevice]);
        } else if (pos?.editorToolsPos) {
            setToolsToolbarPos(pos.editorToolsPos);
        } else {
            setToolsToolbarPos(defaultToolsPos);
        }

        if (pos?.editorQRScannerPosPerDevice?.[selectedDevice]) {
            setQRScannerPos(pos.editorQRScannerPosPerDevice[selectedDevice]);
        } else if (pos?.editorQRScannerPos) {
            setQRScannerPos(pos.editorQRScannerPos);
        }
    }, [game.id, game.toolbarPositions, selectedDevice]);

    // Ensure NEW playzone games/templates get persisted default toolbar positions (so they never stack)
    useEffect(() => {
        if (didSeedEditorToolbarPositionsRef.current) return;

        const pos = game.toolbarPositions;
        const hasEditorToolbarPositions = !!(
            pos?.editorOrientationPos ||
            pos?.editorShowPos ||
            pos?.editorToolsPos ||
            pos?.editorOrientationPosPerDevice ||
            pos?.editorShowPosPerDevice ||
            pos?.editorToolsPosPerDevice
        );

        if (hasEditorToolbarPositions) {
            didSeedEditorToolbarPositionsRef.current = true;
            return;
        }

        const defaults = getDefaultEditorToolbarPositions();

        const updatedToolbarPositions = {
            ...(pos || {}),
            editorOrientationPos: defaults.orientation,
            editorShowPos: defaults.show,
            editorToolsPos: defaults.tools,
            editorOrientationPosPerDevice: {
                ...(pos?.editorOrientationPosPerDevice || {}),
                mobile: defaults.orientation,
                tablet: defaults.orientation,
                desktop: defaults.orientation,
            },
            editorShowPosPerDevice: {
                ...(pos?.editorShowPosPerDevice || {}),
                mobile: defaults.show,
                tablet: defaults.show,
                desktop: defaults.show,
            },
            editorToolsPosPerDevice: {
                ...(pos?.editorToolsPosPerDevice || {}),
                mobile: defaults.tools,
                tablet: defaults.tools,
                desktop: defaults.tools,
            },
        };

        // Immediately update local state (so the UI is correct even before parent re-renders)
        setOrientationToolbarPos(defaults.orientation);
        setShowToolbarPos(defaults.show);
        setToolsToolbarPos(defaults.tools);

        didSeedEditorToolbarPositionsRef.current = true;
        onUpdateGame({
            ...game,
            toolbarPositions: updatedToolbarPositions,
        });
    }, [game.id]);

    // Save toolbar positions to game (device-aware)
    const saveToolbarPositions = () => {
        const existingPos = game.toolbarPositions || {};

        // Save per-device positions
        const updatedGame = {
            ...game,
            toolbarPositions: {
                ...existingPos,
                // Keep default positions for backward compatibility
                editorOrientationPos: orientationToolbarPos,
                editorShowPos: showToolbarPos,
                editorToolsPos: toolsToolbarPos,
                editorQRScannerPos: qrScannerPos,
                // Save device-specific positions
                editorOrientationPosPerDevice: {
                    ...(existingPos.editorOrientationPosPerDevice || {}),
                    [selectedDevice]: orientationToolbarPos,
                },
                editorShowPosPerDevice: {
                    ...(existingPos.editorShowPosPerDevice || {}),
                    [selectedDevice]: showToolbarPos,
                },
                editorToolsPosPerDevice: {
                    ...(existingPos.editorToolsPosPerDevice || {}),
                    [selectedDevice]: toolsToolbarPos,
                },
                editorQRScannerPosPerDevice: {
                    ...(existingPos.editorQRScannerPosPerDevice || {}),
                    [selectedDevice]: qrScannerPos,
                },
            }
        };
        onUpdateGame(updatedGame);
    };

    // Drag handlers for Orientation toolbar
    const handleOrientationPointerDown = (e: React.PointerEvent) => {
        const target = e.target as HTMLElement | null;
        if (target?.closest('button, a, input, textarea, select, [role="button"]')) return;

        e.stopPropagation();
        e.preventDefault();
        setIsDraggingOrientation(true);
        orientationDragOffset.current = { x: e.clientX - orientationToolbarPos.x, y: e.clientY - orientationToolbarPos.y };
        (e.currentTarget as Element).setPointerCapture(e.pointerId);
    };
    const handleOrientationPointerMove = (e: React.PointerEvent) => {
        if (!isDraggingOrientation) return;
        e.stopPropagation();
        e.preventDefault();
        setOrientationToolbarPos({ x: e.clientX - orientationDragOffset.current.x, y: e.clientY - orientationDragOffset.current.y });
    };
    const handleOrientationPointerUp = (e: React.PointerEvent) => {
        if (!isDraggingOrientation) return;
        setIsDraggingOrientation(false);
        try {
            (e.currentTarget as Element).releasePointerCapture(e.pointerId);
        } catch {
            // ignore
        }
        saveToolbarPositions();
    };

    // Drag handlers for Show toolbar
    const handleShowPointerDown = (e: React.PointerEvent) => {
        const target = e.target as HTMLElement | null;
        if (target?.closest('button, a, input, textarea, select, [role="button"]')) return;

        e.stopPropagation();
        e.preventDefault();
        setIsDraggingShow(true);
        showDragOffset.current = { x: e.clientX - showToolbarPos.x, y: e.clientY - showToolbarPos.y };
        (e.currentTarget as Element).setPointerCapture(e.pointerId);
    };
    const handleShowPointerMove = (e: React.PointerEvent) => {
        if (!isDraggingShow) return;
        e.stopPropagation();
        e.preventDefault();
        setShowToolbarPos({ x: e.clientX - showDragOffset.current.x, y: e.clientY - showDragOffset.current.y });
    };
    const handleShowPointerUp = (e: React.PointerEvent) => {
        if (!isDraggingShow) return;
        setIsDraggingShow(false);
        try {
            (e.currentTarget as Element).releasePointerCapture(e.pointerId);
        } catch {
            // ignore
        }
        saveToolbarPositions();
    };

    // Drag handlers for Tools toolbar
    const handleToolsPointerDown = (e: React.PointerEvent) => {
        const target = e.target as HTMLElement | null;
        if (target?.closest('button, a, input, textarea, select, [role="button"]')) return;

        e.stopPropagation();
        e.preventDefault();
        setIsDraggingTools(true);
        toolsDragOffset.current = { x: e.clientX - toolsToolbarPos.x, y: e.clientY - toolsToolbarPos.y };
        (e.currentTarget as Element).setPointerCapture(e.pointerId);
    };
    const handleToolsPointerMove = (e: React.PointerEvent) => {
        if (!isDraggingTools) return;
        e.stopPropagation();
        e.preventDefault();
        setToolsToolbarPos({ x: e.clientX - toolsDragOffset.current.x, y: e.clientY - toolsDragOffset.current.y });
    };
    const handleToolsPointerUp = (e: React.PointerEvent) => {
        if (!isDraggingTools) return;
        setIsDraggingTools(false);
        try {
            (e.currentTarget as Element).releasePointerCapture(e.pointerId);
        } catch {
            // ignore
        }
        saveToolbarPositions();
    };

    // Drag handlers for QR Scanner (percentage-based, like tasks)
    const handleQRScannerPointerDown = (e: React.PointerEvent) => {
        const target = e.target as HTMLElement | null;
        // Allow dragging from the QR button itself, but prevent dragging from other interactive elements
        const isResizeHandle = target?.closest('.qr-resize-handle');
        if (isResizeHandle) return; // Let resize handle work

        // Only start dragging if NOT clicking on the button itself
        // The button will handle its own pointer events for click detection
        const isButton = target?.closest('button');
        if (isButton) return; // Button handles its own clicks

        e.stopPropagation();
        e.preventDefault();
        qrScannerDidDrag.current = false; // Reset drag flag
        setIsDraggingQRScanner(true);

        // Calculate offset in percentage space
        if (backgroundRef.current) {
            const rect = backgroundRef.current.getBoundingClientRect();
            const currentX = (qrScannerPos.x / 100) * rect.width + rect.left;
            const currentY = (qrScannerPos.y / 100) * rect.height + rect.top;
            qrScannerDragOffset.current = { x: e.clientX - currentX, y: e.clientY - currentY };
        }
        (e.currentTarget as Element).setPointerCapture(e.pointerId);
    };
    const handleQRScannerPointerMove = (e: React.PointerEvent) => {
        if (!isDraggingQRScanner || !backgroundRef.current) return;

        const target = e.target as HTMLElement | null;
        // Don't drag if moving from the button itself
        const isButton = target?.closest('button');
        if (isButton) return;

        e.stopPropagation();
        e.preventDefault();

        qrScannerDidDrag.current = true; // Mark that we actually dragged

        // Convert client coordinates to percentage within canvas
        const rect = backgroundRef.current.getBoundingClientRect();
        const x = ((e.clientX - qrScannerDragOffset.current.x - rect.left) / rect.width) * 100;
        const y = ((e.clientY - qrScannerDragOffset.current.y - rect.top) / rect.height) * 100;

        // Clamp to canvas boundaries
        setQRScannerPos({
            x: Math.max(5, Math.min(95, x)),
            y: Math.max(5, Math.min(95, y))
        });
    };
    const handleQRScannerPointerUp = (e: React.PointerEvent) => {
        if (!isDraggingQRScanner) return;
        setIsDraggingQRScanner(false);
        try {
            (e.currentTarget as Element).releasePointerCapture(e.pointerId);
        } catch {
            // ignore
        }
        // IMPORTANT: Reset drag flag for next click interaction
        // This ensures clicking the button after dragging will still open the color picker
        qrScannerDidDrag.current = false;
        // Reset click count after dragging so double-click works properly next time
        qrScannerClickCount.current = 0;
        if (qrScannerClickTimer.current) {
            clearTimeout(qrScannerClickTimer.current);
            qrScannerClickTimer.current = null;
        }
        saveQRScannerSettings();
    };

    // QR Scanner resize handlers
    const handleQRScannerResizeDown = (e: React.PointerEvent) => {
        e.stopPropagation();
        e.preventDefault();
        setIsResizingQRScanner(true);
        qrScannerResizeStart.current = {
            width: qrScannerSize.width,
            height: qrScannerSize.height,
            x: e.clientX,
            y: e.clientY
        };
        (e.currentTarget as Element).setPointerCapture(e.pointerId);
    };

    const handleQRScannerResizeMove = (e: React.PointerEvent) => {
        if (!isResizingQRScanner) return;
        e.stopPropagation();
        e.preventDefault();

        const deltaX = e.clientX - qrScannerResizeStart.current.x;
        const deltaY = e.clientY - qrScannerResizeStart.current.y;
        const newWidth = Math.max(100, qrScannerResizeStart.current.width + deltaX);
        const newHeight = Math.max(40, qrScannerResizeStart.current.height + deltaY);

        setQRScannerSize({ width: newWidth, height: newHeight });
    };

    const handleQRScannerResizeUp = (e: React.PointerEvent) => {
        if (!isResizingQRScanner) return;
        setIsResizingQRScanner(false);
        try {
            (e.currentTarget as Element).releasePointerCapture(e.pointerId);
        } catch {
            // ignore
        }
        saveQRScannerSettings();
    };

    // Save QR Scanner settings to playground device layout
    const saveQRScannerSettings = () => {
        if (activePlayground) {
            const newLayouts = { ...activePlayground.deviceLayouts } || {};
            // Ensure device layout exists before updating
            if (!newLayouts[selectedDevice]) {
                newLayouts[selectedDevice] = {};
            }
            newLayouts[selectedDevice] = {
                ...newLayouts[selectedDevice],
                qrScannerPos: qrScannerPos,
                qrScannerSize: qrScannerSize,
                qrScannerColor: qrScannerColor
            };
            console.log('[PlaygroundEditor] Saving QR Scanner settings:', { qrScannerColor, selectedDevice, newLayouts });
            updatePlayground({ deviceLayouts: newLayouts });
        }
    };

    // QR Scanner function - Show color picker in editor mode, scanner in simulation mode
    const handleQRScanClick = async () => {
        // In simulation mode, show scanner
        if (isSimulationActive) {
            console.log('ðŸŽ® Simulation Mode: Opening QR Scanner');
            setIsQRScannerActive(!isQRScannerActive);
            return;
        }

        // In editor mode, show color picker
        setShowQRColorPicker(true);
    };

    // Handle QR scan result
    const handleQRScan = (data: string) => {
        setQRScannedValue(data);
        console.log('ðŸ“· QR Code scanned:', data);
        // TODO: In simulation mode, you could use the scanned data to trigger actions
        // For example, navigate to a task, update score, etc.
    };

    // Cleanup on unmount
    useEffect(() => {
        return () => {
            // Cleanup is now handled by QRScannerModal
        };
    }, []);

    // Get active playground
    const activePlayground = game.playgrounds?.find(p => p.id === activePlaygroundId) || game.playgrounds?.[0];

    // Check orientation lock from device-specific layout first, then fallback to playground-level
    const isOrientationLocked = (() => {
        if (!activePlayground) return false;
        const deviceLayout = activePlayground.deviceLayouts?.[selectedDevice];
        const orientationSetting = deviceLayout?.orientationLock || activePlayground.orientationLock;
        return !!orientationSetting && orientationSetting !== 'none';
    })();

    const playgroundPoints = activePlayground && game.points ? game.points.filter(p => p.playgroundId === activePlayground.id) : [];

    useEffect(() => {
        if (!activePlayground) return;

        // Get orientation from device-specific layout if available
        if (activePlayground.deviceLayouts?.[selectedDevice]) {
            const deviceLayout = activePlayground.deviceLayouts[selectedDevice];
            // Only change orientation if there's a locked orientation set
            // When unlocked (orientationLock === 'none'), keep the current editorOrientation
            if (deviceLayout.orientationLock && deviceLayout.orientationLock !== 'none') {
                setEditorOrientation(deviceLayout.orientationLock);
            }
            // Note: Removed the 'else' block that reset to default orientation
            // This preserves the current orientation when unlocking

            // Load QR scanner settings from device layout
            if (deviceLayout.qrScannerPos) {
                setQRScannerPos(deviceLayout.qrScannerPos);
            }
            if (deviceLayout.qrScannerSize) {
                setQRScannerSize(deviceLayout.qrScannerSize);
            }
            if (deviceLayout.qrScannerColor) {
                console.log('[PlaygroundEditor] Loading saved QR color:', deviceLayout.qrScannerColor);
                setQRScannerColor(deviceLayout.qrScannerColor);
            } else {
                console.log('[PlaygroundEditor] No saved QR color, using default');
            }
        } else if (activePlayground.orientationLock && activePlayground.orientationLock !== 'none') {
            // Fallback to playground-level orientation for backward compatibility
            setEditorOrientation(activePlayground.orientationLock);
        }
        // Note: Removed the final 'else' block that reset to default orientation
        // This allows orientation to persist when switching devices

        // Initialize visibility states from playground (defaults to true if not set)
        setShowTaskScores(activePlayground.showTaskScores !== false);
        setShowTaskOrder(activePlayground.showTaskOrder !== false);
        setShowTaskActions(activePlayground.showTaskActions !== false);
        setShowTaskNames(activePlayground.showTaskNames !== false);
        setShowTaskStatus(activePlayground.showTaskStatus !== false);
        setShowBackground(activePlayground.showBackground !== false);
        setShowQRScanner(activePlayground.showQRScanner !== false);
    }, [activePlayground?.id, activePlayground?.orientationLock, activePlayground?.deviceLayouts?.[selectedDevice]?.qrScannerColor, activePlayground?.deviceLayouts?.[selectedDevice]?.qrScannerPos, activePlayground?.deviceLayouts?.[selectedDevice]?.qrScannerSize, selectedDevice, activePlayground?.showTaskScores, activePlayground?.showTaskOrder, activePlayground?.showTaskActions, activePlayground?.showTaskNames, activePlayground?.showTaskStatus, activePlayground?.showBackground, activePlayground?.showQRScanner]);

    // Load last used device when switching playgrounds
    useEffect(() => {
        if (activePlayground) {
            const playgroundTasks = game.points?.filter(p => p.playgroundId === activePlayground.id) || [];
            const isNewPlayground = playgroundTasks.length === 0;

            if (isNewPlayground) {
                // New playground: start with tablet mode (default for new playzone games)
                setSelectedDevice('tablet');
            } else {
                // Existing playground: load last used device from localStorage
                const storageKey = `playzone_device_${activePlayground.id}`;
                const savedDevice = localStorage.getItem(storageKey);
                if (savedDevice) {
                    setSelectedDevice(savedDevice as DeviceType);
                }
            }
        }
    }, [activePlayground?.id]);

    // Save selected device to localStorage whenever it changes
    useEffect(() => {
        if (activePlayground) {
            const storageKey = `playzone_device_${activePlayground.id}`;
            localStorage.setItem(storageKey, selectedDevice);
        }
    }, [selectedDevice, activePlayground?.id]);

    // Load and save task sort mode preference
    useEffect(() => {
        if (activePlayground) {
            const storageKey = `playzone_sortmode_${activePlayground.id}`;
            const savedSortMode = localStorage.getItem(storageKey);
            if (savedSortMode) {
                setTaskSortMode(savedSortMode as 'order' | 'actions');
            }
        }
    }, [activePlayground?.id]);

    useEffect(() => {
        if (activePlayground) {
            const storageKey = `playzone_sortmode_${activePlayground.id}`;
            localStorage.setItem(storageKey, taskSortMode);
        }
    }, [taskSortMode, activePlayground?.id]);

    // Load and save zoom level
    useEffect(() => {
        if (activePlayground) {
            const storageKey = `playzone_zoom_${activePlayground.id}`;
            const savedZoom = localStorage.getItem(storageKey);
            if (savedZoom) {
                setZoom(parseFloat(savedZoom));
            }
        }
    }, [activePlayground?.id]);

    useEffect(() => {
        if (activePlayground) {
            const storageKey = `playzone_zoom_${activePlayground.id}`;
            localStorage.setItem(storageKey, zoom.toString());
        }
    }, [zoom, activePlayground?.id]);

    // Auto-collapse all source tasks on mount when in actions mode
    useEffect(() => {
        if (activePlayground && taskSortMode === 'actions') {
            const uniquePlaygroundPoints = game.points.filter(p => p.playgroundId === activePlayground.id);
            const sourceTasks = uniquePlaygroundPoints.filter(p =>
                p.logic?.onOpen?.length > 0 ||
                p.logic?.onCorrect?.length > 0 ||
                p.logic?.onIncorrect?.length > 0
            );
            setCollapsedSources(new Set(sourceTasks.map(t => t.id)));
        }
    }, [activePlayground?.id, taskSortMode, game.points]);

    // Deduplicate to prevent "same key" errors
    const uniquePlaygroundPoints = Array.from(new Map(playgroundPoints.map(p => [p.id, p])).values());

    // Device-specific position helpers
    const getDevicePosition = (point: GamePoint): { x: number; y: number } => {
        // Priority: devicePositions[selectedDevice] > playgroundPosition > default
        if (point.devicePositions?.[selectedDevice]) {
            return point.devicePositions[selectedDevice];
        }
        // Fallback to legacy playgroundPosition
        if (point.playgroundPosition) {
            return point.playgroundPosition;
        }
        // Default position
        return { x: 50, y: 50 };
    };

    const setDevicePosition = (point: GamePoint, position: { x: number; y: number }): Partial<GamePoint> => {
        // Store in device-specific position
        const devicePositions = {
            ...point.devicePositions,
            [selectedDevice]: position
        };
        return { devicePositions };
    };

    // Handlers
    const updatePlayground = (updates: Partial<Playground>) => {
        if (!activePlayground) return;
        const updated = game.playgrounds?.map(p => p.id === activePlayground.id ? { ...p, ...updates } : p);
        onUpdateGame({ ...game, playgrounds: updated });
    };

    const addNewZone = () => {
        const existingZones = game.playgrounds || [];
        const zoneNumber = existingZones.length + 1;

        // Initialize device layouts with default configurations

        const newZone: Playground = {
            id: `pg-${Date.now()}`,
            title: `Global ${zoneNumber}`,
            buttonVisible: true,
            iconId: 'default',
            location: { lat: 0, lng: 0 },
            orientationLock: 'landscape',
            deviceLayouts: {
                mobile: {
                    orientationLock: 'landscape',
                    qrScannerPos: { x: 85, y: 85 }, // Percentage-based (85%, 85%)
                    qrScannerSize: { width: 140, height: 48 },
                    qrScannerColor: '#f97316', // Orange-500 default
                    iconPositions: {},
                    buttonVisible: true,
                    iconScale: 1.0,
                },
                tablet: {
                    orientationLock: 'landscape',
                    qrScannerPos: { x: 85, y: 85 }, // Percentage-based (85%, 85%)
                    qrScannerSize: { width: 140, height: 48 },
                    qrScannerColor: '#f97316', // Orange-500 default
                    iconPositions: {},
                    buttonVisible: true,
                    iconScale: 1.0,
                },
                desktop: {
                    orientationLock: 'landscape',
                    qrScannerPos: { x: 85, y: 85 }, // Percentage-based (85%, 85%)
                    qrScannerSize: { width: 140, height: 48 },
                    qrScannerColor: '#f97316', // Orange-500 default
                    iconPositions: {},
                    buttonVisible: true,
                    iconScale: 1.0,
                },
            },
        };

        const updatedPlaygrounds = [...existingZones, newZone];
        onUpdateGame({ ...game, playgrounds: updatedPlaygrounds });
        setActivePlaygroundId(newZone.id);

        // Open drawers by default for new zones
        setIsDrawerOpen(true);
        setIsTasksDrawerOpen(true);
    };

    const handleResetBackground = () => {
        // Reset background to default centered state
        // This ensures the background image is properly centered and scaled
        updatePlayground({
            backgroundScale: 1,
            backgroundOffset: { x: 0, y: 0 }
        });
    };

    const handleImageUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            const url = await uploadImage(file);
            if (url) updatePlayground({ imageUrl: url });
        }
    };

    const handleIconUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            const url = await uploadImage(file);
            if (url) updatePlayground({ iconUrl: url });
        }
        // Reset to allow re-uploading same file
        if (iconInputRef.current) iconInputRef.current.value = '';
    };

    const handleAudioUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) {
            const url = await uploadImage(file);
            if (url) updatePlayground({ audioUrl: url, audioLoop: true });
        }
        // Reset to allow re-uploading same file
        if (audioInputRef.current) audioInputRef.current.value = '';
    };

    const handleGenerateAiBackground = async (keywords: string) => {
        if (!keywords.trim() || !activePlayground) return;

        setIsGeneratingBackground(true);
        try {
            console.log('[PlaygroundEditor] Generating AI background for:', { keywords, zone: activePlayground.title });
            const imageUrl = await generateAiBackground(keywords, activePlayground.title);

            if (imageUrl) {
                console.log('[PlaygroundEditor] Background generated successfully');
                updatePlayground({ imageUrl });
                setShowAiBackgroundPrompt(false);
                setAiBackgroundPromptValue('');
            } else {
                console.warn('[PlaygroundEditor] AI returned null - check console for details');
                alert('âš ï¸ Image generation failed\n\nGemini 2.5 Flash Image did not return image data. This could mean:\n\n1. The prompt may have been filtered by safety settings\n2. Your API key may have reached its quota\n3. The content may be too complex or ambiguous\n\nCheck the browser console (F12) for detailed error logs.\n\nTry:\nâ€¢ Using simpler, descriptive keywords (e.g., "forest sunset", "medieval castle", "ocean waves")\nâ€¢ Avoiding potentially sensitive content\nâ€¢ Being more specific in your description\nâ€¢ Uploading an image instead');
            }
        } catch (error: any) {
            console.error('[PlaygroundEditor] Error generating background:', error);
            const errorMessage = error?.message || '';
            if (errorMessage.includes('AI API Key missing')) {
                setPendingBackgroundKeywords(keywords);
                setShowGeminiKeyModal(true);
            } else {
                alert('Error generating background. Please check your API key and try again.');
            }
        } finally {
            setIsGeneratingBackground(false);
        }
    };

    const handleApiKeySaved = () => {
        // Retry the background generation with the pending keywords
        if (pendingBackgroundKeywords) {
            handleGenerateAiBackground(pendingBackgroundKeywords);
            setPendingBackgroundKeywords(null);
        }
    };

    const selectedTask = game.points?.find(p => p.id === selectedTaskId && p.playgroundId === activePlayground?.id);

    const updateTask = (updates: Partial<GamePoint>) => {
        if (!selectedTask) return;
        onUpdateGame({
            ...game,
            points: game.points.map(p => p.id === selectedTask.id ? { ...p, ...updates } : p)
        });
    };

    const updatePointDirectly = (pointId: string, updates: Partial<GamePoint>) => {
        onUpdateGame({
            ...game,
            points: game.points?.map(p => p.id === pointId ? { ...p, ...updates } : p)
        });
    };

    const toggleBulkIconTarget = (pointId: string) => {
        setBulkIconTargets(prev => {
            const newSet = new Set(prev);
            if (newSet.has(pointId)) {
                newSet.delete(pointId);
            } else {
                newSet.add(pointId);
            }
            return newSet;
        });
    };

    const applyBulkIcon = () => {
        if (!bulkIconSourceId || bulkIconTargets.size === 0) return;

        const sourceTask = game.points?.find(p => p.id === bulkIconSourceId);
        if (!sourceTask) return;

        const iconPayload = {
            iconId: sourceTask.iconId,
            iconUrl: sourceTask.iconUrl
        };

        onUpdateGame({
            ...game,
            points: game.points?.map(p =>
                bulkIconTargets.has(p.id) ? { ...p, ...iconPayload } : p
            )
        });

        // Reset bulk icon mode
        setBulkIconMode(false);
        setBulkIconSourceId(null);
        setBulkIconTargets(new Set());
    };

    const handleTaskIconUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file && selectedTask) {
            const url = await uploadImage(file);
            if (url) updateTask({ iconUrl: url });
        }
        if (taskIconInputRef.current) taskIconInputRef.current.value = '';
    };

    const handleCompletedTaskIconUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file && selectedTask) {
            const url = await uploadImage(file);
            if (url) updateTask({ completedIconUrl: url });
        }
        if (completedTaskIconInputRef.current) completedTaskIconInputRef.current.value = '';
    };

    const handleGenerateTaskIcon = async (prompt: string) => {
        if (!prompt.trim()) {
            alert('Please enter a description for the icon');
            return;
        }

        setIsGeneratingIcon(true);
        try {
            console.log('[PlaygroundEditor] Generating AI icon for:', prompt);
            const iconUrl = await generateAiImage(prompt, 'simple icon style, transparent background');

            if (iconUrl) {
                console.log('[PlaygroundEditor] Icon generated successfully');
                // If a task is selected, update task icon; otherwise update zone icon
                if (selectedTask) {
                    if (editingCompletedIcon) {
                        updateTask({ completedIconUrl: iconUrl });
                    } else {
                        updateTask({ iconUrl });
                    }
                } else {
                    updatePlayground({ iconUrl });
                }
            } else {
                console.warn('[PlaygroundEditor] AI returned null - check console for details');
                alert('âš ï¸ Image generation failed\n\nGemini 2.5 Flash Image did not return image data. This could mean:\n\n1. The prompt may have been filtered by safety settings\n2. Your API key may have reached its quota\n3. The content may be too complex or ambiguous\n\nCheck the browser console (F12) for detailed error logs.\n\nTry:\nâ€¢ Using simpler, descriptive keywords\nâ€¢ Avoiding potentially sensitive content\nâ€¢ Being more specific in your description');
            }
        } catch (error: any) {
            console.error('[PlaygroundEditor] Icon generation error:', error);
            const errorMessage = error?.message || '';
            if (errorMessage.includes('AI API Key missing')) {
                setShowGeminiKeyModal(true);
            } else {
                alert('Error generating icon. Please check your API key and try again.\n\n' + errorMessage);
            }
        } finally {
            setIsGeneratingIcon(false);
        }
    };

    const handleSearchCompanyLogo = async (companyName: string) => {
        if (!companyName.trim()) {
            alert('Please enter a company name');
            return;
        }
        if (!selectedTask) return;

        setIsSearchingLogo(true);
        try {
            console.log('[Logo Search] Searching for:', companyName);
            const logoUrl = await searchLogoUrl(companyName);

            if (logoUrl) {
                console.log('[Logo Search] Found logo:', logoUrl);
                if (editingCompletedIcon) {
                    updateTask({ completedIconUrl: logoUrl });
                } else {
                    updateTask({ iconUrl: logoUrl });
                }
                setShowLogoPrompt(false);
                setLogoCompanyName('');
            } else {
                alert('Could not find a logo for this company. Please try uploading manually.');
            }
        } catch (error) {
            console.error('[Logo Search] Error:', error);
            alert('Failed to search for logo. Please try again.');
        } finally {
            setIsSearchingLogo(false);
        }
    };

    // Throttle playground position updates to prevent excessive re-renders and DB writes
    const pendingUpdatesRef = useRef<Record<string, { x: number; y: number }>>({});
    const updateTimeoutRef = useRef<number | null>(null);

    const flushPendingUpdates = () => {
        if (Object.keys(pendingUpdatesRef.current).length > 0) {
            const updates = { ...pendingUpdatesRef.current };
            pendingUpdatesRef.current = {};

            onUpdateGame({
                ...game,
                points: game.points?.map(p => {
                    if (updates[p.id]) {
                        // Store in device-specific position
                        return { ...p, ...setDevicePosition(p, updates[p.id]) };
                    }
                    return p;
                })
            });
        }
        updateTimeoutRef.current = null;
    };

    const updatePointPlaygroundPosition = (pointId: string, playgroundPosition: { x: number; y: number }) => {
        // Store update locally
        pendingUpdatesRef.current[pointId] = playgroundPosition;

        // Throttle: Only update DB at most once per 150ms while dragging
        if (updateTimeoutRef.current === null) {
            updateTimeoutRef.current = window.setTimeout(flushPendingUpdates, 150);
        }
    };

    const toggleMarkTask = (taskId: string) => {
        setMarkedTaskIds(prev => {
            const newSet = new Set(prev);
            if (newSet.has(taskId)) {
                newSet.delete(taskId);
            } else {
                newSet.add(taskId);
            }
            return newSet;
        });
    };

    const requestScreenOrientation = async (orientation: 'portrait' | 'landscape') => {
        try {
            const screenOrientation = (screen as any).orientation || (screen as any).webkitOrientation;
            if (screenOrientation && screenOrientation.lock) {
                const target = orientation === 'landscape' ? 'landscape-primary' : 'portrait-primary';
                await screenOrientation.lock(target);
                console.log(`Screen orientation locked to ${orientation}`);
            }
        } catch (error) {
            console.warn('Could not lock screen orientation:', error);
        }
    };

    const handleSnapAllToGrid = () => {
        // Dynamically calculate columns based on number of icons
        const totalIcons = uniquePlaygroundPoints.length;
        let COLS = 3;

        if (totalIcons > 12) COLS = 4;
        if (totalIcons > 20) COLS = 5;

        const PADDING = 5;
        const ROW_HEIGHT = 20; // Space between rows

        // Sort points by current Y position (top to bottom), then X (left to right)
        const sortedPoints = [...uniquePlaygroundPoints].sort((a, b) => {
            const aPos = getDevicePosition(a);
            const bPos = getDevicePosition(b);
            const aY = aPos.y;
            const bY = bPos.y;
            const aX = aPos.x;
            const bX = bPos.x;

            // Group into rows (every 15% difference = new row)
            const rowDiff = Math.abs(aY - bY);
            if (rowDiff > 15) return aY - bY;
            return aX - bX;
        });

        // Snap all points to grid and arrange in rows
        const snappedPoints = sortedPoints.map((point, index) => {
            const row = Math.floor(index / COLS);
            const col = index % COLS;

            // Calculate grid-aligned position with dynamic column spacing
            const colWidth = (100 - (PADDING * 2)) / COLS;
            const x = PADDING + (col * colWidth) + (colWidth / 2);
            const y = PADDING + (row * ROW_HEIGHT) + (ROW_HEIGHT / 2);

            return {
                ...point,
                ...setDevicePosition(point, {
                    x: Math.round(x * 10) / 10,
                    y: Math.round(y * 10) / 10
                })
            };
        });

        // Update game with snapped points
        onUpdateGame({
            ...game,
            points: game.points?.map(p => {
                const snapped = snappedPoints.find(sp => sp.id === p.id);
                return snapped ? { ...p, playgroundPosition: snapped.playgroundPosition } : p;
            })
        });
    };

    const handleSnapMarkedToGrid = () => {
        if (markedTaskIds.size === 0) {
            alert('Please mark at least one task to snap');
            return;
        }

        // Get only marked tasks
        const markedPoints = uniquePlaygroundPoints.filter(p => markedTaskIds.has(p.id));

        // Group marked tasks by Y position (Â±10% tolerance = "same row")
        const rowTolerance = 10;
        const rows: GamePoint[][] = [];

        const sortedByY = [...markedPoints].sort((a, b) => {
            const aY = getDevicePosition(a).y;
            const bY = getDevicePosition(b).y;
            return aY - bY;
        });

        sortedByY.forEach(point => {
            const pointY = getDevicePosition(point).y;
            let foundRow = false;

            for (const row of rows) {
                const rowY = getDevicePosition(row[0]).y;
                if (Math.abs(pointY - rowY) <= rowTolerance) {
                    row.push(point);
                    foundRow = true;
                    break;
                }
            }

            if (!foundRow) {
                rows.push([point]);
            }
        });

        // Sort each row by X position
        rows.forEach(row => {
            row.sort((a, b) => {
                const aX = getDevicePosition(a).x;
                const bX = getDevicePosition(b).x;
                return aX - bX;
            });
        });

        // Detect grid dimensions: find max columns in any row
        const numRows = rows.length;
        const numCols = Math.max(...rows.map(row => row.length));

        // Padding from edges (increased to prevent text labels cutoff)
        const PADDING = 12; // 12% padding from all edges (~2cm on most screens)
        const availableWidth = 100 - (PADDING * 2);
        const availableHeight = 100 - (PADDING * 2);

        // Calculate spacing between icons (not icon positions)
        const colSpacing = numCols > 1 ? availableWidth / (numCols - 1) : 0;
        const rowSpacing = numRows > 1 ? availableHeight / (numRows - 1) : 0;

        // Position all icons in a proper rectangular grid
        const snappedMarkedPoints = rows.flatMap((row, rowIndex) => {
            // Calculate Y position for this row
            const rowY = numRows === 1 ? 50 : PADDING + (rowIndex * rowSpacing);

            return row.map((point, colIndex) => {
                // Calculate X position for this column
                const colX = numCols === 1 ? 50 : PADDING + (colIndex * colSpacing);

                return {
                    ...point,
                    ...setDevicePosition(point, {
                        x: Math.round(colX * 10) / 10, // Round to 1 decimal
                        y: Math.round(rowY * 10) / 10  // Round to 1 decimal
                    })
                };
            });
        });

        // Update game with snapped marked points
        onUpdateGame({
            ...game,
            points: game.points?.map(p => {
                const snapped = snappedMarkedPoints.find(sp => sp.id === p.id);
                if (snapped && snapped.devicePositions) {
                    return { ...p, devicePositions: snapped.devicePositions };
                }
                return p;
            })
        });

        // Exit mark mode and clear marked tasks
        setIsMarkMode(false);
        setMarkedTaskIds(new Set());
    };

    // Pan/Zoom, etc.
    const handleWheel = (e: React.WheelEvent) => {
        // Default behavior: zoom in/out
        e.preventDefault();
        const scaleAmount = -e.deltaY * 0.001;
        setZoom(z => Math.max(0.2, Math.min(5, z * (1 + scaleAmount))));

        // Note: Removed panning on scroll - users can drag to pan instead
        // This makes mousewheel zoom the primary interaction, which is more intuitive
    };

    const handleMouseDown = (e: React.MouseEvent) => {
        if (dragTaskRef.current.id) return;
        if (isBackgroundLocked) return;
        setIsDragging(true);
        setDragStart({ x: e.clientX - pan.x, y: e.clientY - pan.y });
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (dragTaskRef.current.id) return;

        // Track mouse position in draw mode
        if (drawMode.active && drawMode.sourceTaskId && canvasRef.current) {
            const rect = canvasRef.current.getBoundingClientRect();
            setDrawMode(prev => ({
                ...prev,
                mousePosition: {
                    x: ((e.clientX - rect.left) / rect.width) * 100,
                    y: ((e.clientY - rect.top) / rect.height) * 100
                }
            }));
        }

        if (isDragging) {
            setPan({ x: e.clientX - dragStart.x, y: e.clientY - dragStart.y });
        }
    };

    const handleMouseUp = () => {
        setIsDragging(false);
    };

    const handleCenterBackground = () => {
        setPan({ x: 0, y: 0 });
        setZoom(1);
    };

    // Calculate viewport dimensions based on device type and orientation
    const getViewportDimensions = () => {
        // Desktop mode: use 100% to fill available space
        if (selectedDevice === 'desktop') {
            return { width: '100%', height: '100%', aspectRatio: 'auto' };
        }

        // Mobile and Tablet: use fixed device dimensions
        const specs = DEVICE_SPECS[selectedDevice];
        if (!specs) return { width: '100%', height: '100%', aspectRatio: 'auto' };

        const width = editorOrientation === 'portrait'
            ? Math.min(specs.width, specs.height)
            : Math.max(specs.width, specs.height);
        const height = editorOrientation === 'portrait'
            ? Math.max(specs.width, specs.height)
            : Math.min(specs.width, specs.height);

        return {
            width: `${width}px`,
            height: `${height}px`,
            aspectRatio: `${width} / ${height}` as any
        };
    };

    const viewportDims = getViewportDimensions();

    const bgStyle: React.CSSProperties = {
        backgroundImage: showBackground && activePlayground?.imageUrl ? `url(${activePlayground.imageUrl})` : 'none',
        backgroundSize: activePlayground?.backgroundStyle === 'stretch' ? '100% 100%' : (activePlayground?.backgroundStyle === 'cover' ? 'cover' : 'contain'),
        backgroundPosition: 'center',
        backgroundRepeat: 'no-repeat',
        width: viewportDims.width,
        height: viewportDims.height,
        transform: `translate(${pan.x}px, ${pan.y}px) scale(${zoom})`,
        transition: isDragging ? 'none' : 'transform 0.1s ease-out'
    };

    const handleTaskPointerDown = (e: React.PointerEvent, point: GamePoint) => {
        e.preventDefault();
        e.stopPropagation();

        const rect = backgroundRef.current?.getBoundingClientRect();
        if (!rect) return;

        const devicePos = getDevicePosition(point);
        const currentX = devicePos.x;
        const currentY = devicePos.y;

        const centerX = rect.left + (currentX / 100) * rect.width;
        const centerY = rect.top + (currentY / 100) * rect.height;

        dragTaskRef.current = {
            id: point.id,
            offsetX: e.clientX - centerX,
            offsetY: e.clientY - centerY,
            startClientX: e.clientX,
            startClientY: e.clientY,
            moved: false
        };

        setDraggingTaskId(point.id);
        setDragVisualPosition(null); // Start with game state position
        (e.currentTarget as HTMLElement).setPointerCapture(e.pointerId);
    };

    const handleTaskPointerMove = (e: React.PointerEvent) => {
        const id = dragTaskRef.current.id;
        if (!id) return;

        const rect = backgroundRef.current?.getBoundingClientRect();
        if (!rect) return;

        const dx = e.clientX - dragTaskRef.current.startClientX;
        const dy = e.clientY - dragTaskRef.current.startClientY;
        if (!dragTaskRef.current.moved && (Math.abs(dx) > 2 || Math.abs(dy) > 2)) {
            dragTaskRef.current.moved = true;
        }

        const x = ((e.clientX - rect.left - dragTaskRef.current.offsetX) / rect.width) * 100;
        const y = ((e.clientY - rect.top - dragTaskRef.current.offsetY) / rect.height) * 100;

        const clamped = {
            x: Math.max(0, Math.min(100, Math.round(x * 10) / 10)),
            y: Math.max(0, Math.min(100, Math.round(y * 10) / 10))
        };

        // Update visual position immediately for smooth dragging
        setDragVisualPosition(clamped);

        // Batch game state updates with throttle
        updatePointPlaygroundPosition(id, clamped);

        // Check if dragging over delete zone
        const deleteZoneRect = document.getElementById('delete-zone-btn')?.getBoundingClientRect();
        if (deleteZoneRect) {
            const isOver = e.clientX >= deleteZoneRect.left && e.clientX <= deleteZoneRect.right &&
                          e.clientY >= deleteZoneRect.top && e.clientY <= deleteZoneRect.bottom;
            setIsOverDeleteZone(isOver);
        }
    };

    const handleTaskPointerUp = (e: React.PointerEvent) => {
        const id = dragTaskRef.current.id;
        if (!id) return;

        e.preventDefault();
        e.stopPropagation();

        const wasClick = !dragTaskRef.current.moved;

        // Check if dropped on delete zone
        if (isOverDeleteZone) {
            onUpdateGame({
                ...game,
                points: game.points?.filter(p => p.id !== id)
            });
            setSelectedTaskId(null);
        } else {
            // Flush any pending updates immediately on pointer up
            if (updateTimeoutRef.current !== null) {
                clearTimeout(updateTimeoutRef.current);
                flushPendingUpdates();
            }

            if (wasClick) {
                setSelectedTaskId(id);
            }
        }

        dragTaskRef.current = { id: null, offsetX: 0, offsetY: 0, startClientX: 0, startClientY: 0, moved: false };
        setDraggingTaskId(null);
        setDragVisualPosition(null);
        setIsOverDeleteZone(false);
    };

    // Handle snap-to-road selection box
    const handleSnapToRoadStart = (e: React.MouseEvent) => {
        if (!snapToRoadMode) return;
        e.preventDefault();
        e.stopPropagation();
        setSelectionBox({
            start: { x: e.clientX, y: e.clientY },
            current: { x: e.clientX, y: e.clientY }
        });
    };

    const handleSnapToRoadMove = (e: React.MouseEvent) => {
        if (!snapToRoadMode || !selectionBox.start) return;
        e.preventDefault();
        e.stopPropagation();
        setSelectionBox({
            start: selectionBox.start,
            current: { x: e.clientX, y: e.clientY }
        });
    };

    const handleSnapToRoadEnd = async (e: React.MouseEvent) => {
        if (!snapToRoadMode || !selectionBox.start || !selectionBox.current || !activePlayground) return;
        e.preventDefault();
        e.stopPropagation();

        // Get canvas bounds to convert screen coords to map coords
        const canvas = canvasRef.current;
        if (!canvas) return;

        const rect = canvas.getBoundingClientRect();

        // Convert screen coordinates to canvas relative coordinates
        const startX = (selectionBox.start.x - rect.left) / zoom + pan.x;
        const startY = (selectionBox.start.y - rect.top) / zoom + pan.y;
        const endX = (selectionBox.current.x - rect.left) / zoom + pan.x;
        const endY = (selectionBox.current.y - rect.top) / zoom + pan.y;

        // Find tasks within the selection box
        const tasksToSnap = game.points?.filter(point => {
            const pos = point.playgroundPosition;
            if (!pos) return false;

            const minX = Math.min(startX, endX);
            const maxX = Math.max(startX, endX);
            const minY = Math.min(startY, endY);
            const maxY = Math.max(startY, endY);

            return pos.x >= minX && pos.x <= maxX && pos.y >= minY && pos.y <= maxY;
        });

        if (tasksToSnap.length === 0) {
            alert('No tasks selected. Please draw a larger selection box.');
            setSelectionBox({ start: null, current: null });
            return;
        }

        // Show loading state
        const originalPoints = tasksToSnap.map(p => p.location);

        try {
            // Snap tasks to road
            const snappedLocations = await snapPointsToRoad(originalPoints);

            // Update the game with snapped locations
            const updatedPoints = game.points?.map(point => {
                const taskIndex = tasksToSnap.findIndex(t => t.id === point.id);
                if (taskIndex >= 0) {
                    return {
                        ...point,
                        location: snappedLocations[taskIndex] || point.location
                    };
                }
                return point;
            });

            await updateActiveGame({ ...game, points: updatedPoints }, `Snapped ${tasksToSnap.length} tasks to road`);
            alert(`âœ“ Successfully snapped ${tasksToSnap.length} task${tasksToSnap.length !== 1 ? 's' : ''} to road`);
        } catch (error) {
            console.error('Error snapping to road:', error);
            alert('Failed to snap tasks to road. Please check the console for details.');
        }

        // Reset selection box and mode
        setSelectionBox({ start: null, current: null });
        setSnapToRoadMode(false);
    };

    // CRITICAL NULL CHECK: Prevent crashes if no playground exists
    if (!activePlayground) {
        return (
            <div className="fixed inset-0 z-[5000] bg-[#0f172a] text-white flex items-center justify-center">
                <div className="text-center p-8 bg-slate-900 rounded-2xl border border-red-500 shadow-2xl max-w-md">
                    <AlertTriangle className="w-16 h-16 text-red-500 mx-auto mb-4" />
                    <h2 className="text-2xl font-black uppercase mb-2">No Playground Available</h2>
                    <p className="text-slate-400 mb-6">This game has no playgrounds configured. Please create one to continue.</p>
                    <button
                        onClick={onClose}
                        className="px-6 py-3 bg-orange-600 hover:bg-orange-700 text-white font-bold rounded-lg transition-colors"
                    >
                        CLOSE EDITOR
                    </button>
                </div>
            </div>
        );
    }

    return (
        <div className="fixed inset-0 z-[5000] bg-[#0f172a] text-white flex flex-row overflow-hidden font-sans animate-in fade-in">

            {/* Top-Right Settings Gear - Fixed Position */}
            {!isSimulationActive && onOpenGameSettings && (
                <button
                    onClick={(e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        onOpenGameSettings();
                    }}
                    className="absolute top-6 right-6 z-[6000] p-2 text-orange-500 hover:text-orange-400 transition-all hover:scale-110 pointer-events-auto group"
                    title="Open Game Settings - Configure game rules, timing, and appearance"
                >
                    <Settings className="w-6 h-6" />
                </button>
            )}

            {/* Simulation Mode Banner - Absolute Positioned */}
            {isSimulationActive && (
                <div className="absolute top-0 left-0 right-0 px-6 py-4 flex items-center justify-between z-[6000] bg-purple-600 border-b-4 border-purple-500 animate-in slide-in-from-top-4">
                    <div className="flex items-center gap-4">
                        <PlayCircle className="w-6 h-6 text-white animate-pulse" />
                        <div>
                            <h3 className="text-lg font-black uppercase tracking-wider text-white">
                                ðŸŽ® SIMULATION MODE ACTIVE
                            </h3>
                            <p className="text-sm font-bold text-white/90">
                                Click tasks to open and solve them. Score: {simulationScore} | Team: {simulationTeam?.name}
                            </p>
                        </div>
                    </div>
                    <button
                        onClick={() => {
                            setIsSimulationActive(false);
                            setSimulationScore(0);
                            setSimulationTeam(null);
                            setActiveSimulationTaskId(null);
                            setShowRanking(false);

                            // Stop background music
                            if (simulationBgAudioRef.current) {
                                simulationBgAudioRef.current.pause();
                                simulationBgAudioRef.current.currentTime = 0;
                                simulationBgAudioRef.current = null;
                            }
                        }}
                        className="px-6 py-3 bg-white/20 hover:bg-white/30 text-white font-black uppercase tracking-wider rounded-lg transition-all flex items-center gap-2 border-2 border-white/30"
                    >
                        <X className="w-5 h-5" /> EXIT SIMULATION
                    </button>
                </div>
            )}

            {/* Draw Mode Banner - Absolute Positioned */}
            {drawMode.active && drawMode.sourceTaskId && (
                <div className={`absolute top-0 left-0 right-0 px-6 py-4 flex items-center justify-between z-[6000] border-b-4 animate-in slide-in-from-top-4 ${
                    drawMode.trigger === 'onCorrect'
                        ? 'bg-green-600 border-green-500'
                        : drawMode.trigger === 'onIncorrect'
                        ? 'bg-red-600 border-red-500'
                        : 'bg-yellow-600 border-yellow-500'
                }`}>
                    <div className="flex items-center gap-4">
                        <PenTool className="w-6 h-6 text-white animate-pulse" />
                        <div>
                            <h3 className="text-lg font-black uppercase tracking-wider text-white">
                                {drawMode.trigger === 'onCorrect' ? 'âœ“ IF CORRECT' : drawMode.trigger === 'onIncorrect' ? 'âœ— IF INCORRECT' : 'âš¡ WHEN OPENED'} DRAW MODE
                            </h3>
                            <p className="text-sm font-bold text-white/90">
                                Click tasks to connect them. Click multiple to create a flow. Press ESC or click Exit to finish.
                            </p>
                        </div>
                    </div>
                    <button
                        onClick={() => setDrawMode({ active: false, trigger: null, sourceTaskId: null, mousePosition: null })}
                        className="px-6 py-3 bg-white/20 hover:bg-white/30 text-white font-black uppercase tracking-wider rounded-lg transition-all flex items-center gap-2 border-2 border-white/30"
                    >
                        <X className="w-5 h-5" /> EXIT DRAW MODE
                    </button>
                </div>
            )}

            {/* LEFT SIDEBAR EDITOR - COLLAPSIBLE DRAWER */}
            <div className={`flex flex-col border-r border-slate-800 bg-[#0f172a] shadow-2xl z-20 transition-all duration-300 ease-in-out ${
                isDrawerOpen ? 'w-[360px]' : 'w-0'
            } overflow-hidden`}>
                {/* Header */}
                <div className="p-5 border-b border-slate-800 flex justify-between items-center bg-[#0f172a]">
                    <div className="flex items-center gap-3">
                        <LayoutGrid className="w-5 h-5 text-orange-500" />
                        <div>
                            <h2 className="text-sm font-black uppercase tracking-widest text-white">PLAYZONE EDITOR</h2>
                            <p className="text-[10px] text-slate-500 font-bold uppercase tracking-wider">{game.playgrounds?.length || 0} ZONES ACTIVE</p>
                        </div>
                    </div>
                    <div className="flex items-center gap-1">
                        {/* Game Settings Clockwheel */}
                        {onOpenGameSettings && (
                            <button
                                onClick={(e) => {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    onOpenGameSettings();
                                }}
                                className="text-orange-500 hover:text-orange-400 transition-all p-2 hover:scale-110"
                                title="Open Game Settings"
                            >
                                <Settings className="w-5 h-5" />
                            </button>
                        )}
                        <button
                            onClick={toggleAllSections}
                            className="text-slate-400 hover:text-orange-400 transition-colors p-2"
                            title={(() => {
                                const anyExpanded = !isBackgroundImageCollapsed ||
                                                   !isBackgroundMusicCollapsed || !isDeviceCollapsed ||
                                                   !isOrientationCollapsed || !isShowCollapsed || !isLayoutCollapsed;
                                return anyExpanded ? "Collapse All Sections" : "Expand All Sections";
                            })()}
                        >
                            <ChevronsUpDown className="w-5 h-5" />
                        </button>
                        <button
                            onClick={() => setIsDrawerOpen(false)}
                            className="text-orange-500 hover:text-orange-400 transition-colors p-2 -mr-2"
                            title="Close Settings"
                        >
                            <ChevronLeft className="w-6 h-6" />
                        </button>
                    </div>
                </div>

                {/* Content */}
                <div className="flex-1 overflow-y-auto p-5 space-y-6 custom-scrollbar">
                    {/* Active Zone Card */}
                    <div className="bg-[#1e293b]/50 border border-slate-700 rounded-xl p-4">
                        <div className="flex justify-between items-center gap-2">
                            <div className="flex flex-col flex-1">
                                <span className="text-[10px] font-black text-slate-500 uppercase tracking-widest mb-1">ZONE TITLE</span>
                                <input
                                    type="text"
                                    value={activePlayground.title}
                                    onChange={(e) => updatePlayground({ title: e.target.value })}
                                    className="bg-transparent border-b border-slate-600 text-sm font-bold text-white uppercase focus:border-orange-500 outline-none pb-1 w-full"
                                />
                            </div>
                            {onOpenGameSettings && (
                                <button
                                    onClick={(e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        onOpenGameSettings();
                                    }}
                                    className="p-2 bg-orange-600 hover:bg-orange-700 text-white rounded-lg transition-all shadow-lg"
                                    title="Game Settings"
                                >
                                    <Settings className="w-4 h-4" />
                                </button>
                            )}
                        </div>

                        {/* HUD Appearance */}
                        <div>
                            <button
                                onClick={() => setIsHudAppearanceCollapsed(!isHudAppearanceCollapsed)}
                                className="flex justify-between items-center mb-2 w-full hover:bg-slate-800/50 rounded-lg p-2 -mx-2 transition-colors group"
                            >
                                <span className="text-[10px] font-black text-slate-500 group-hover:text-slate-400 uppercase tracking-widest flex items-center gap-1">
                                    <MousePointerClick className="w-3 h-3" /> HUD BUTTON APPEARANCE
                                </span>
                                <ChevronDown className={`w-5 h-5 text-orange-500 group-hover:text-orange-400 transition-transform ${isHudAppearanceCollapsed ? '-rotate-90' : ''}`} />
                            </button>

                            {!isHudAppearanceCollapsed && (
                                <div className="space-y-3">
                                    {/* Custom Icon Preview */}
                                    {activePlayground.iconUrl && (
                                <div className="mb-3 p-3 bg-slate-800 rounded-lg border border-slate-700 flex items-center justify-between">
                                    <div className="flex items-center gap-3">
                                        <img src={activePlayground.iconUrl} alt="Custom Icon" className="w-8 h-8 object-contain" />
                                        <div className="flex flex-col gap-0.5">
                                            <span className="text-[10px] font-bold text-slate-300 uppercase tracking-wide">
                                                {activePlayground.iconUrl === activePlayground.imageUrl ? 'BACKGROUND' : 'CUSTOM'} ICON
                                            </span>
                                            {activePlayground.iconUrl === activePlayground.imageUrl && (
                                                <span className="text-[9px] text-slate-400 uppercase tracking-wide">Using background image</span>
                                            )}
                                        </div>
                                    </div>
                                    <button
                                        onClick={() => updatePlayground({ iconUrl: undefined, iconId: 'default' })}
                                        className="p-1.5 text-slate-500 hover:text-red-500 transition-colors"
                                        title="Remove Custom Icon"
                                    >
                                        <X className="w-4 h-4" />
                                    </button>
                                </div>
                            )}

                            <div className="grid grid-cols-4 gap-2 mb-3">
                                {['default', 'star', 'flag', 'trophy', 'camera', 'question', 'skull', 'treasure', 'music', 'nature', 'world'].map((iconKey) => {
                                    const Icon = ICON_COMPONENTS[iconKey as IconId];
                                    const isActive = activePlayground.iconId === iconKey && !activePlayground.iconUrl;
                                    return (
                                        <button
                                            key={iconKey}
                                            onClick={() => updatePlayground({ iconId: iconKey as IconId, iconUrl: undefined })}
                                            className={`aspect-square rounded-lg flex items-center justify-center transition-all ${isActive ? 'bg-orange-600 text-white shadow-lg scale-105' : 'bg-slate-800 text-slate-400 hover:bg-slate-700'}`}
                                        >
                                            <Icon className="w-4 h-4" />
                                        </button>
                                    );
                                })}
                            </div>

                            <div className="grid grid-cols-2 gap-2 mb-4">
                                <button
                                    onClick={() => iconInputRef.current?.click()}
                                    className="py-2.5 border border-dashed border-slate-600 rounded-lg text-[10px] font-bold text-slate-400 uppercase hover:text-white hover:border-slate-400 transition-colors flex items-center justify-center gap-1.5"
                                >
                                    <Upload className="w-3 h-3" /> UPLOAD
                                </button>
                                <input ref={iconInputRef} type="file" className="hidden" accept="image/*" onChange={handleIconUpload} />

                                <button
                                    onClick={() => {
                                        setAiIconPromptValue('');
                                        setShowAiIconPrompt(true);
                                    }}
                                    disabled={isGeneratingIcon}
                                    className={`py-2.5 rounded-lg text-[10px] font-bold uppercase flex items-center justify-center gap-1.5 transition-all ${
                                        isGeneratingIcon
                                            ? 'bg-purple-600/50 text-purple-300 cursor-wait border border-purple-500'
                                            : 'border border-dashed border-purple-600 text-purple-400 hover:text-purple-300 hover:border-purple-400'
                                    }`}
                                    title="Generate zone icon with AI"
                                >
                                    {isGeneratingIcon ? (
                                        <>
                                            <div className="w-3 h-3 border-2 border-purple-300 border-t-transparent rounded-full animate-spin" />
                                            <span className="text-[9px]">GENERATING...</span>
                                        </>
                                    ) : (
                                        <>
                                            <Wand2 className="w-3 h-3" /> AI ICON
                                        </>
                                    )}
                                </button>

                                {activePlayground.imageUrl && (
                                    <button
                                        onClick={() => updatePlayground({ iconUrl: activePlayground.imageUrl })}
                                        className={`col-span-2 py-2.5 rounded-lg text-[10px] font-bold uppercase flex items-center justify-center gap-2 transition-colors ${
                                            activePlayground.iconUrl === activePlayground.imageUrl
                                                ? 'bg-purple-600 text-white border border-purple-500'
                                                : 'bg-slate-800 border border-slate-600 text-slate-300 hover:bg-slate-700 hover:text-white'
                                        }`}
                                        title="Use Background Image as Icon"
                                    >
                                        <ImageIcon className="w-3 h-3" /> USE BACKGROUND AS ICON
                                    </button>
                                )}
                            </div>

                            <div className="mt-4">
                                <div className="flex justify-between text-[9px] font-bold text-slate-500 uppercase mb-1">
                                    <span>SIZE</span>
                                    <span>{activePlayground.buttonSize || 80}PX</span>
                                </div>
                                <input 
                                    type="range" 
                                    min="40" 
                                    max="120" 
                                    step="5"
                                    value={activePlayground.buttonSize || 80}
                                    onChange={(e) => updatePlayground({ buttonSize: parseInt(e.target.value) })}
                                    className="w-full h-1 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-orange-500"
                                />
                            </div>
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Orange Divider */}
                    <div className="h-0.5 bg-gradient-to-r from-transparent via-orange-500 to-transparent opacity-30 my-4" />

                    {/* Device Selection */}
                    <div>
                        <button
                            onClick={() => setIsDeviceCollapsed(!isDeviceCollapsed)}
                            className="flex justify-between items-center mb-2 w-full hover:bg-slate-800/50 rounded-lg p-2 -mx-2 transition-colors group"
                        >
                            <span className="text-[10px] font-black text-slate-500 group-hover:text-slate-400 uppercase tracking-widest">DEVICE</span>
                            <ChevronDown className={`w-5 h-5 text-orange-500 group-hover:text-orange-400 transition-transform ${isDeviceCollapsed ? '-rotate-90' : ''}`} />
                        </button>

                        {!isDeviceCollapsed && (
                            <div className="grid grid-cols-3 gap-2">
                                <button
                                    onClick={() => setSelectedDevice('mobile')}
                                    className={`flex flex-col items-center gap-2 py-4 rounded-xl transition-all ${
                                        selectedDevice === 'mobile'
                                            ? 'bg-blue-600 text-white shadow-lg ring-2 ring-blue-400'
                                            : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white border border-slate-700'
                                    }`}
                                    title="Mobile (375Ã—812)"
                                >
                                    <Smartphone className="w-6 h-6" />
                                    <span className="text-[10px] font-black uppercase">MOBILE</span>
                                </button>
                                <button
                                    onClick={() => setSelectedDevice('tablet')}
                                    className={`flex flex-col items-center gap-2 py-4 rounded-xl transition-all ${
                                        selectedDevice === 'tablet'
                                            ? 'bg-cyan-600 text-white shadow-lg ring-2 ring-cyan-400'
                                            : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white border border-slate-700'
                                    }`}
                                    title="Tablet (1024Ã—768)"
                                >
                                    <Tablet className="w-6 h-6" />
                                    <span className="text-[10px] font-black uppercase">TABLET</span>
                                </button>
                                <button
                                    onClick={() => setSelectedDevice('desktop')}
                                    className={`flex flex-col items-center gap-2 py-4 rounded-xl transition-all ${
                                        selectedDevice === 'desktop'
                                            ? 'bg-purple-600 text-white shadow-lg ring-2 ring-purple-400'
                                            : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white border border-slate-700'
                                    }`}
                                    title="Desktop (1920Ã—1080)"
                                >
                                    <Monitor className="w-6 h-6" />
                                    <span className="text-[10px] font-black uppercase">DESKTOP</span>
                                </button>
                            </div>
                        )}
                    </div>

                    {/* Orange Divider */}
                    <div className="h-0.5 bg-gradient-to-r from-transparent via-orange-500 to-transparent opacity-30 my-4" />

                    {/* Orientation Selection */}
                    <div>
                        <button
                            onClick={() => setIsOrientationCollapsed(!isOrientationCollapsed)}
                            className="flex justify-between items-center mb-2 w-full hover:bg-slate-800/50 rounded-lg p-2 -mx-2 transition-colors group"
                        >
                            <span className="text-[10px] font-black text-slate-500 group-hover:text-slate-400 uppercase tracking-widest">ORIENTATION</span>
                            <ChevronDown className={`w-5 h-5 text-orange-500 group-hover:text-orange-400 transition-transform ${isOrientationCollapsed ? '-rotate-90' : ''}`} />
                        </button>

                        {!isOrientationCollapsed && (
                            <div className="space-y-3">
                                <div className="grid grid-cols-3 gap-2">
                                    <button
                                        onClick={() => {
                                            setEditorOrientation('portrait');
                                            if (activePlayground) {
                                                const newLayouts = { ...activePlayground.deviceLayouts };
                                                // If already locked, update the lock to the new orientation
                                                if (isOrientationLocked) {
                                                    newLayouts[selectedDevice] = {
                                                        ...newLayouts[selectedDevice],
                                                        orientationLock: 'portrait',
                                                    };
                                                    updatePlayground({ deviceLayouts: newLayouts });
                                                }
                                            }
                                        }}
                                        className={`flex flex-col items-center gap-2 py-4 rounded-xl transition-all ${
                                            editorOrientation === 'portrait'
                                                ? 'bg-orange-600 text-white shadow-lg ring-2 ring-orange-400'
                                                : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white border border-slate-700'
                                        }`}
                                        title="Portrait orientation"
                                    >
                                        <Smartphone className="w-6 h-6" />
                                        <span className="text-[10px] font-black uppercase">PORTRAIT</span>
                                    </button>
                                    <button
                                        onClick={() => {
                                            setEditorOrientation('landscape');
                                            if (activePlayground) {
                                                const newLayouts = { ...activePlayground.deviceLayouts };
                                                // If already locked, update the lock to the new orientation
                                                if (isOrientationLocked) {
                                                    newLayouts[selectedDevice] = {
                                                        ...newLayouts[selectedDevice],
                                                        orientationLock: 'landscape',
                                                    };
                                                    updatePlayground({ deviceLayouts: newLayouts });
                                                }
                                            }
                                        }}
                                        className={`flex flex-col items-center gap-2 py-4 rounded-xl transition-all ${
                                            editorOrientation === 'landscape'
                                                ? 'bg-orange-600 text-white shadow-lg ring-2 ring-orange-400'
                                                : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white border border-slate-700'
                                        }`}
                                        title="Landscape orientation"
                                    >
                                        <Monitor className="w-6 h-6" />
                                        <span className="text-[10px] font-black uppercase">LAND</span>
                                    </button>
                                    <button
                                        onClick={() => {
                                            if (!activePlayground) return;
                                            const newLayouts = { ...activePlayground.deviceLayouts };
                                            if (isOrientationLocked) {
                                                newLayouts[selectedDevice] = {
                                                    ...newLayouts[selectedDevice],
                                                    orientationLock: 'none',
                                                };
                                            } else {
                                                newLayouts[selectedDevice] = {
                                                    ...newLayouts[selectedDevice],
                                                    orientationLock: editorOrientation,
                                                };
                                            }
                                            updatePlayground({ deviceLayouts: newLayouts });
                                        }}
                                        className={`flex flex-col items-center gap-2 py-4 rounded-xl transition-all ${
                                            isOrientationLocked
                                                ? 'bg-orange-600 text-white shadow-lg ring-2 ring-orange-400'
                                                : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white border border-slate-700'
                                        }`}
                                        title={isOrientationLocked ? 'Unlock orientation' : 'Lock to selected orientation'}
                                    >
                                        <Lock className="w-6 h-6" />
                                        <span className="text-[10px] font-black uppercase">LOCK</span>
                                    </button>
                                </div>
                                {isOrientationLocked && (
                                    <div className="bg-orange-900/30 border border-orange-500/50 rounded-lg p-3 text-[9px] text-orange-300 uppercase font-bold tracking-wide">
                                        âš ï¸ Locked to {activePlayground?.deviceLayouts?.[selectedDevice]?.orientationLock === 'landscape' ? 'LANDSCAPE' : 'PORTRAIT'}
                                    </div>
                                )}
                            </div>
                        )}
                    </div>

                    {/* Orange Divider */}
                    <div className="h-0.5 bg-gradient-to-r from-transparent via-orange-500 to-transparent opacity-30 my-4" />

                    {/* SHOW IN GAME Section */}
                    <div>
                        <button
                            onClick={() => setIsShowCollapsed(!isShowCollapsed)}
                            className="flex justify-between items-center mb-2 w-full hover:bg-slate-800/50 rounded-lg p-2 -mx-2 transition-colors group"
                        >
                            <span className="text-[10px] font-black text-slate-500 group-hover:text-slate-400 uppercase tracking-widest">SHOW IN GAME</span>
                            <ChevronDown className={`w-5 h-5 text-orange-500 group-hover:text-orange-400 transition-transform ${isShowCollapsed ? '-rotate-90' : ''}`} />
                        </button>

                        {!isShowCollapsed && (
                            <div className="grid grid-cols-4 gap-2">
                                <button
                                    onClick={() => {
                                        const newValue = !showTaskScores;
                                        setShowTaskScores(newValue);
                                        updatePlayground({ showTaskScores: newValue });
                                    }}
                                    className={`flex flex-col items-center gap-1 py-2 rounded-lg transition-all ${
                                        showTaskScores ? 'bg-orange-600 text-white shadow-lg' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                                    }`}
                                    title="Show/Hide Scores"
                                >
                                    <span className="text-base font-bold">$</span>
                                    <span className="text-[8px] font-black uppercase">SCORE</span>
                                </button>
                                <button
                                    onClick={() => {
                                        const newValue = !showTaskOrder;
                                        setShowTaskOrder(newValue);
                                        updatePlayground({ showTaskOrder: newValue });
                                    }}
                                    className={`flex flex-col items-center gap-1 py-2 rounded-lg transition-all ${
                                        showTaskOrder ? 'bg-orange-600 text-white shadow-lg' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                                    }`}
                                >
                                    <span className="text-base font-bold">#</span>
                                    <span className="text-[8px] font-black uppercase">ORDER</span>
                                </button>
                                <button
                                    onClick={() => {
                                        const newValue = !showTaskActions;
                                        setShowTaskActions(newValue);
                                        updatePlayground({ showTaskActions: newValue });
                                    }}
                                    className={`flex flex-col items-center gap-1 py-2 rounded-lg transition-all ${
                                        showTaskActions ? 'bg-orange-600 text-white shadow-lg' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                                    }`}
                                >
                                    <Zap className="w-4 h-4" />
                                    <span className="text-[8px] font-black uppercase">ACTIONS</span>
                                </button>
                                <button
                                    onClick={() => {
                                        const newValue = !showTaskNames;
                                        setShowTaskNames(newValue);
                                        updatePlayground({ showTaskNames: newValue });
                                    }}
                                    className={`flex flex-col items-center gap-1 py-2 rounded-lg transition-all ${
                                        showTaskNames ? 'bg-orange-600 text-white shadow-lg' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                                    }`}
                                >
                                    <Type className="w-4 h-4" />
                                    <span className="text-[8px] font-black uppercase">NAME</span>
                                </button>
                                <button
                                    onClick={() => {
                                        const newValue = !showTaskStatus;
                                        setShowTaskStatus(newValue);
                                        updatePlayground({ showTaskStatus: newValue });
                                    }}
                                    className={`flex flex-col items-center gap-1 py-2 rounded-lg transition-all ${
                                        showTaskStatus ? 'bg-orange-600 text-white shadow-lg' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                                    }`}
                                >
                                    <CheckCircle className="w-4 h-4" />
                                    <span className="text-[8px] font-black uppercase">ANSWERS</span>
                                </button>
                                <button
                                    onClick={() => {
                                        const newValue = !showBackground;
                                        setShowBackground(newValue);
                                        updatePlayground({ showBackground: newValue });
                                    }}
                                    className={`flex flex-col items-center gap-1 py-2 rounded-lg transition-all ${
                                        showBackground ? 'bg-orange-600 text-white shadow-lg' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                                    }`}
                                >
                                    <ImageIcon className="w-4 h-4" />
                                    <span className="text-[8px] font-black uppercase">BG</span>
                                </button>
                                <button
                                    onClick={() => {
                                        const newValue = !showQRScanner;
                                        setShowQRScanner(newValue);
                                        updatePlayground({ showQRScanner: newValue });
                                    }}
                                    className={`flex flex-col items-center gap-1 py-2 rounded-lg transition-all ${
                                        showQRScanner ? 'bg-orange-600 text-white shadow-lg' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                                    }`}
                                >
                                    <QrCode className="w-4 h-4" />
                                    <span className="text-[8px] font-black uppercase">QR</span>
                                </button>
                                <button
                                    onClick={() => setShowRanking(!showRanking)}
                                    className={`flex flex-col items-center gap-1 py-2 rounded-lg transition-all ${
                                        showRanking ? 'bg-purple-600 text-white shadow-lg' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                                    }`}
                                    title="Show/Hide Ranking Popup"
                                >
                                    <Trophy className="w-4 h-4" />
                                    <span className="text-[8px] font-black uppercase">RANK</span>
                                </button>
                            </div>
                        )}
                    </div>

                    {/* Orange Divider */}
                    <div className="h-0.5 bg-gradient-to-r from-transparent via-orange-500 to-transparent opacity-30 my-4" />

                    {/* LAYOUT Section */}
                    <div>
                        <button
                            onClick={() => setIsLayoutCollapsed(!isLayoutCollapsed)}
                            className="flex justify-between items-center mb-2 w-full hover:bg-slate-800/50 rounded-lg p-2 -mx-2 transition-colors group"
                        >
                            <span className="text-[10px] font-black text-slate-500 group-hover:text-slate-400 uppercase tracking-widest">LAYOUT</span>
                            <ChevronDown className={`w-5 h-5 text-orange-500 group-hover:text-orange-400 transition-transform ${isLayoutCollapsed ? '-rotate-90' : ''}`} />
                        </button>

                        {!isLayoutCollapsed && (
                            <div className="space-y-2">
                                <div className="grid grid-cols-2 gap-2">
                                    <button
                                        onClick={() => setShowGrid(!showGrid)}
                                        className={`flex items-center justify-center gap-2 py-3 rounded-xl transition-all ${
                                            showGrid ? 'bg-blue-600 text-white shadow-lg' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                                        }`}
                                    >
                                        <Grid className="w-5 h-5" />
                                        <span className="text-[10px] font-black uppercase">GRID</span>
                                    </button>
                                    <button
                                        onClick={() => {
                                            if (isMarkMode) {
                                                setIsMarkMode(false);
                                                setMarkedTaskIds(new Set());
                                            } else {
                                                setIsMarkMode(true);
                                            }
                                        }}
                                        className={`flex items-center justify-center gap-2 py-3 rounded-xl transition-all ${
                                            isMarkMode ? 'bg-orange-600 text-white shadow-lg animate-pulse' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                                        }`}
                                        title={isMarkMode ? 'Exit mark mode' : 'Select tasks to snap to grid'}
                                    >
                                        <MousePointer2 className="w-5 h-5" />
                                        <span className="text-[10px] font-black uppercase">MARK</span>
                                    </button>
                                </div>
                                {isMarkMode && (
                                    <div className="space-y-2">
                                        {/* Mark All / Unmark All Button */}
                                        <button
                                            onClick={() => {
                                                if (markedTaskIds.size === uniquePlaygroundPoints.length) {
                                                    // If all are marked, unmark all
                                                    setMarkedTaskIds(new Set());
                                                } else {
                                                    // Mark all icons in current playground
                                                    setMarkedTaskIds(new Set(uniquePlaygroundPoints.map(p => p.id)));
                                                }
                                            }}
                                            className="w-full py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-xl flex items-center justify-center gap-2 font-black uppercase text-[10px] shadow-lg transition-colors"
                                            title={markedTaskIds.size === uniquePlaygroundPoints.length ? 'Unmark all tasks' : 'Mark all tasks'}
                                        >
                                            <Target className="w-4 h-4" />
                                            {markedTaskIds.size === uniquePlaygroundPoints.length ? 'UNMARK ALL' : 'MARK ALL'}
                                        </button>

                                        {/* Snap Button - only show when tasks are marked */}
                                        {markedTaskIds.size > 0 && (
                                            <button
                                                onClick={handleSnapMarkedToGrid}
                                                className="w-full py-3 bg-green-600 hover:bg-green-700 text-white rounded-xl flex items-center justify-center gap-2 font-black uppercase text-[10px] shadow-lg transition-colors"
                                                title={`Snap ${markedTaskIds.size} selected task(s) to grid`}
                                            >
                                                <Check className="w-4 h-4" />
                                                SNAP ({markedTaskIds.size})
                                            </button>
                                        )}
                                    </div>
                                )}
                                <button
                                    onClick={() => setIsBackgroundImageCollapsed(!isBackgroundImageCollapsed)}
                                    className={`w-full flex items-center justify-center gap-2 py-3 rounded-xl transition-all ${
                                        !isBackgroundImageCollapsed ? 'bg-purple-600 text-white shadow-lg' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 border border-slate-700'
                                    }`}
                                >
                                    <ImageIcon className="w-5 h-5" />
                                    <span className="text-[10px] font-black uppercase">BACKGROUND</span>
                                </button>

                                {/* Background Image Content - Revealed when BACKGROUND button is clicked */}
                                {!isBackgroundImageCollapsed && (
                                    <div className="space-y-3 mt-3 p-3 bg-slate-900/50 border border-slate-700 rounded-xl">
                                        <div
                                            className="aspect-video bg-slate-900 border border-slate-700 rounded-xl overflow-hidden relative group cursor-pointer hover:border-slate-500 transition-colors"
                                            onClick={() => fileInputRef.current?.click()}
                                        >
                                            {activePlayground.imageUrl ? (
                                                <img src={activePlayground.imageUrl} className="w-full h-full object-cover opacity-50 group-hover:opacity-100 transition-opacity" />
                                            ) : (
                                                <div className="w-full h-full flex items-center justify-center text-slate-600">
                                                    <ImageIcon className="w-8 h-8" />
                                                </div>
                                            )}
                                            <div className="absolute inset-0 flex items-center justify-center bg-black/50 opacity-0 group-hover:opacity-100 transition-opacity">
                                                <span className="text-[9px] font-bold text-white uppercase tracking-widest">UPLOAD IMAGE</span>
                                            </div>
                                        </div>
                                        <input ref={fileInputRef} type="file" className="hidden" accept="image/*" onChange={handleImageUpload} />

                                        {/* AI Background & Upload Buttons */}
                                        <div className="space-y-2">
                                            {/* API Key Status Indicator */}
                                            <div className="flex items-center gap-2 bg-slate-800/50 border border-slate-700 rounded-lg p-2">
                                                <div className={`w-2 h-2 rounded-full ${typeof window !== 'undefined' && localStorage.getItem('GEMINI_API_KEY') ? 'bg-green-500' : 'bg-red-500'}`} />
                                                <span className="text-[9px] font-bold uppercase text-slate-400 flex-1">
                                                    {typeof window !== 'undefined' && localStorage.getItem('GEMINI_API_KEY') ? 'API Key Configured' : 'No API Key'}
                                                </span>
                                                <button
                                                    onClick={() => setShowGeminiKeyModal(true)}
                                                    className="px-2 py-1 bg-indigo-600 hover:bg-indigo-500 text-white rounded text-[8px] font-bold uppercase tracking-wider transition-colors"
                                                    title="Configure Gemini API Key"
                                                >
                                                    {typeof window !== 'undefined' && localStorage.getItem('GEMINI_API_KEY') ? 'Update' : 'Set Key'}
                                                </button>
                                            </div>

                                            <div className="flex gap-2">
                                                <button
                                                    onClick={() => setShowAiBackgroundPrompt(true)}
                                                    disabled={isGeneratingBackground}
                                                    className="flex-1 py-2.5 bg-gradient-to-r from-purple-600 to-purple-700 hover:from-purple-700 hover:to-purple-800 disabled:opacity-50 text-white rounded-lg font-bold uppercase text-[10px] tracking-wide flex items-center justify-center gap-2 transition-colors shadow-lg"
                                                >
                                                    <Wand2 className="w-4 h-4" />
                                                    {isGeneratingBackground ? 'GENERATING...' : 'AI BACKGROUND'}
                                                </button>
                                            </div>
                                        </div>

                                        {/* Scaling Options */}
                                        <div className="flex bg-slate-800 rounded-lg p-1 border border-slate-700">
                                            {['contain', 'cover', 'stretch'].map((style) => (
                                                <button
                                                    key={style}
                                                    onClick={() => updatePlayground({ backgroundStyle: style as any })}
                                                    className={`flex-1 py-1.5 text-[9px] font-bold uppercase rounded transition-colors ${activePlayground.backgroundStyle === style || (!activePlayground.backgroundStyle && style === 'contain') ? 'bg-slate-600 text-white shadow-sm' : 'text-slate-400 hover:text-white'}`}
                                                >
                                                    {style}
                                                </button>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>

                    {/* Background Audio Section - At Bottom */}
                    <div>
                        <button
                            onClick={() => setIsBackgroundMusicCollapsed(!isBackgroundMusicCollapsed)}
                            className="flex justify-between items-center mb-2 w-full hover:bg-slate-800/50 rounded-lg p-2 -mx-2 transition-colors group"
                        >
                            <span className="text-[10px] font-black text-slate-500 group-hover:text-slate-400 uppercase tracking-widest flex items-center gap-1">
                                <Music className="w-3 h-3" /> BACKGROUND MUSIC
                            </span>
                            <ChevronDown className={`w-5 h-5 text-orange-500 group-hover:text-orange-400 transition-transform ${isBackgroundMusicCollapsed ? '-rotate-90' : ''}`} />
                        </button>

                        {!isBackgroundMusicCollapsed && (
                            <div className="bg-slate-900 border border-slate-700 rounded-xl p-3 space-y-3">
                            {/* Add New Track Button */}
                            <button
                                onClick={() => audioInputRef.current?.click()}
                                className="w-full py-3 border border-dashed border-indigo-600 rounded-lg text-indigo-400 hover:text-indigo-300 hover:border-indigo-400 hover:bg-indigo-500/10 transition-all flex items-center justify-center gap-2"
                            >
                                <Plus className="w-4 h-4" />
                                <span className="text-[10px] font-bold uppercase">ADD MP3 TRACK</span>
                            </button>
                            <input ref={audioInputRef} type="file" className="hidden" accept="audio/mp3,audio/mpeg,audio/wav" onChange={handleAudioUpload} />

                            {/* Active Track Display */}
                            {activePlayground.audioUrl && (
                                <div className="space-y-2">
                                    <div className="flex items-center justify-between bg-slate-800 p-2 rounded-lg">
                                        <div className="flex items-center gap-2 text-indigo-400 flex-1 min-w-0">
                                            <Music className="w-4 h-4 flex-shrink-0" />
                                            <span className="text-[10px] font-bold uppercase truncate">PLAYING NOW</span>
                                        </div>
                                        <button
                                            onClick={() => updatePlayground({ audioUrl: undefined, audioLoop: true })}
                                            className="p-1.5 hover:bg-red-500/20 text-slate-500 hover:text-red-500 rounded-lg transition-colors flex-shrink-0"
                                            title="Remove track"
                                        >
                                            <Trash2 className="w-4 h-4" />
                                        </button>
                                    </div>

                                    {/* Playback Mode Controls */}
                                    <div className="flex bg-slate-800 rounded-lg p-1 border border-slate-700 gap-1">
                                        <button
                                            onClick={() => updatePlayground({ audioLoop: false })}
                                            className={`flex-1 py-2 text-[9px] font-bold uppercase rounded flex items-center justify-center gap-1 transition-colors ${activePlayground.audioLoop === false ? 'bg-indigo-600 text-white shadow-sm' : 'text-slate-400 hover:text-white'}`}
                                            title="Play once then stop"
                                        >
                                            <PlayCircle className="w-3 h-3" /> PLAY ONCE
                                        </button>
                                        <button
                                            onClick={() => updatePlayground({ audioLoop: true })}
                                            className={`flex-1 py-2 text-[9px] font-bold uppercase rounded flex items-center justify-center gap-1 transition-colors ${activePlayground.audioLoop !== false ? 'bg-indigo-600 text-white shadow-sm' : 'text-slate-400 hover:text-white'}`}
                                            title="Loop continuously"
                                        >
                                            <Repeat className="w-3 h-3" /> LOOP
                                        </button>
                                    </div>
                                </div>
                            )}

                            {!activePlayground.audioUrl && (
                                <div className="text-center py-3">
                                    <p className="text-[10px] text-slate-500 uppercase tracking-wide">No music loaded</p>
                                </div>
                            )}
                        </div>
                        )}
                    </div>

                </div>

                {/* Footer Buttons - Fixed at bottom */}
                <div className="p-5 border-t border-slate-800 flex-shrink-0 space-y-3">
                    {/* SIMULATOR Button */}
                    <button
                        onClick={(e) => {
                            e.preventDefault();
                            e.stopPropagation();

                            if (isSimulationActive) {
                                // Stop simulation
                                setIsSimulationActive(false);
                                setSimulationScore(0);
                                setSimulationTeam(null);
                                setActiveSimulationTaskId(null);
                                setShowRanking(false);

                                // Stop background music
                                if (simulationBgAudioRef.current) {
                                    simulationBgAudioRef.current.pause();
                                    simulationBgAudioRef.current.currentTime = 0;
                                    simulationBgAudioRef.current = null;
                                }
                            } else {
                                // Start simulation
                                const testTeam = {
                                    id: 'sim-test-team',
                                    gameId: game.id,
                                    name: 'TEST',
                                    joinCode: 'TEST00',
                                    score: 0,
                                    members: [{ name: 'Simulator', deviceId: 'sim-device', photo: '' }],
                                    updatedAt: new Date().toISOString()
                                };
                                setSimulationTeam(testTeam);
                                setSimulationScore(0);
                                setIsSimulationActive(true);
                                setShowRanking(true);
